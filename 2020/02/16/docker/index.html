<!DOCTYPE html>
<html lang="en">
<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="undefined">
    <meta name="baidu-site-verification" content="aifbHeRmzy">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content="rimin, rimin Blog, Rimin的博客, Rimin, html, css, javascript, js, JavaScript, Node">
    <title>docker初识与实践 - Rimin的博客 | Rimin&#39;s Blog</title>
    <!-- Web App Manifest -->
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://rimin.github.io">

    <link rel="manifest" href="/pwa/manifest.json">
  
    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
  
    <!-- Safari Webpage Icon    by-HJB -->
    <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
    <!-- Bootstrap Core CSS -->
      <link rel="stylesheet" href="/css/bootstrap.min.css">
  
      <!-- Custom CSS -->
      <link rel="stylesheet" href="/css/hux-blog.min.css">
  
      <!-- Pygments Github CSS -->
      <link rel="stylesheet" href="/css/highlight.css">

      <link rel="stylesheet" href="/css/rocket.css">

      <link rel="stylesheet" href="/css/signature.css">
  
      <link rel="stylesheet" href="/css/toc.css">
    <link rel="stylesheet" type="text/css" href="https://c.mipcdn.com/static/v1/mip.css">
    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->
  
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    
    <!-- ga & ba script hoook -->
    <script></script>
</head>
    <!-- hack iOS CSS :active style -->
    <body ontouchstart="">
        <!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/home-bg.jpg')
            /*post*/
        
    }
</style>

<link rel="stylesheet" href="/css/post-style.css">


<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#docker" title="docker">docker</a>
                            
                              <a class="tag" href="/tags/#backend" title="backend">backend</a>
                            
                        </div>
                        <h1>docker初识与实践</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Rimin on
                            2020-02-16
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>



        <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Rimin&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <!-- <form class="navbar-form navbar-left">
                    <div class="form-group">
                        <input type="text" name="content" class="form-control" placeholder="Search">
                    </div>
                </form> -->
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Categories</a>
                        </li>
                        
                    

                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


        <!-- Main Content -->
        
<!-- Image to hack wechat -->
<!-- <img src="https://rimin.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->


<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h3><span id="认识docker"> 认识docker</span></h3>
<blockquote>
<p>docker(<a href="https://github.com/moby/moby" target="_blank" rel="noopener">github 地址</a>), 是一个开放源代码软件项目，让应用程序部署在“软件货柜下”的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker利用<code>Linux</code>核心中的资源分离机制，例如<code>cgroups</code>，以及<code>Linux</code>核心名字空间，来创建独立的容器。</p>
</blockquote>
<h5><span id="虚拟机-vs-docker"> 虚拟机 VS docker</span></h5>
<p>虚拟化技术大家比较熟悉的是虚拟机</p>
<blockquote>
<p>所谓虚拟机，通常来说就是通过一个虚拟机监视器 ( Virtual Machine Monitor ) 的设施来隔离操作系统与硬件或者应用程序和操作系统，以此达到虚拟化的目的。</p>
</blockquote>
<p>但是虚拟机有一个最大的弊端，就是性能低下。可以看以下这张图：</p>
<p><img src="https://github.com/Rimin/MyBlog/blob/master/source/img/docker/1.png?raw=true" alt="由于没有了虚拟操作系统和虚拟机监视器这两个层次，大幅减少了应用程序运行带来的额外消耗"></p>
<p><code>docker</code>的产生，为开发，测试，运维等带来了巨大额便利，不仅如此，由于当下是云计算时代，应用的开发也逐渐趋向服务化甚至微服务化，<code>docker</code>应用更加广泛。<br>
口说无凭，可以看一下docker 官方对 Docker 在工作上带来的提升做了调查研究，分别从工作效率的提升和技术设计投入的减少等方面数据化了 Docker 所做出的突出贡献:</p>
<p><img src="https://github.com/Rimin/rimin.github.io/blob/master/img/docker/2.png?raw=true" alt="image2"></p>
<h5><span id="docker-的核心技术"> docker 的核心技术</span></h5>
<p>docker 的核心技术实现归结于此三大技术：</p>
<ul>
<li>NameSpace: 命名空间是 Linux 核心在 2.4 版本后逐渐引入的一项用于运行隔离的模块. 以进程为例，通过 PID Namespace,在这个空间中运行的进程，完全感知不到外界系统中的其他进程或是其他进程命名空间中运行的进程。于是，利用 PID Namespace，Docker 就实现了容器中隔离程序运行中进程隔离这一目标。</li>
<li>Contrl Group: 资源控制组 ( 常缩写为 CGroups ) 是 Linux 内核在 2.6 版本后逐渐引入的一项对计算机资源控制的模块。虚拟化除了制造出虚拟的环境隔离同一物理平台运行的不同程序之外，另一大作用就是控制硬件资源的分配，CGroups 的使用正是为了这样的目的。</li>
<li>Union File System： 是一种能够同时挂载不同实际文件或文件夹到同一目录，形成一种联合文件结构的文件系统。Docker 创新的将其引入到容器实现中，用它解决虚拟环境对文件系统占用过量，实现虚拟环境快速启停等问题。后面接触到docker volume(docker 数据卷)时，就会发现他们都存储在统一的目录如： <code>/var/lib/docker/volumes/8d47f68f0aad71a7d091cb0904c827/_data</code>（可以通过<code>docker inspect containerid</code> 查看目录地址）,同时，文件的更新像git一样只是将修改的部分记录在案，再更新源文件，大大减少了存储空间的使用。</li>
</ul>
<h5><span id="docker的核心组成"> docker的核心组成</span></h5>
<p>docker的四大核心概念的介绍</p>
<ol>
<li>镜像：<br>
所谓镜像，可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。</li>
<li>容器：<br>
如果把镜像理解为编程中的类，那么容器就可以理解为类的实例。在容器技术中，容器就是用来隔离虚拟环境的基础设施，而在 Docker 里，它也被引申为隔离出来的虚拟环境。</li>
<li>数据卷：<br>
在以往的虚拟机中，我们通常直接采用虚拟机的文件系统作为应用数据等文件的存储位置。为了保证数据的独立性，我们通常会单独挂载一个文件系统来存放数据。而在 UnionFS 的加持下，除了能够从宿主操作系统中挂载目录外，还能够建立独立的目录持久存放数据，或者在容器间共享。在 Docker 中，通过这几种方式进行数据共享或持久化的文件或目录，我们都称为数据卷 ( Volume )。</li>
<li>网络：<br>
在 Docker 中，实现了强大的网络功能，我们不但能够十分轻松的对每个容器的网络进行配置，还能在容器间建立虚拟网络，将数个容器包裹其中，同时与其他网络环境隔离。</li>
</ol>
<p><img src="https://github.com/Rimin/rimin.github.io/blob/master/img/docker/6.png?raw=true" alt="image6"></p>
<p>目前 Docker 官方为我们提供了五种 Docker 网络驱动，分别是：<code>Bridge Driver</code>、<code>Host Driver</code>、<code>Overlay Driver</code>、<code>MacLan Driver</code>、<code>None Driver</code></p>
<blockquote>
<ol>
<li><code>Bridge Driver</code>: 默认网络驱动程序. 如果未指定驱动程序，则这是您正在创建的网络类型. 当您的应用程序在需要通信的独立容器中运行时，通常会使用网桥网络。</li>
<li><code>Host Driver</code> : 对于独立容器，取消容器与Docker主机之间的网络隔离，并直接使用主机的网络. host仅可用于Docker 17.06及更高版本上的集群服务.</li>
<li><code>Overlay Driver</code>: 覆盖网络将多个Docker守护程序连接在一起，并使群集服务能够相互通信. 还可以使用覆盖网络来促进群集服务和独立容器之间或不同Docker守护程序上的两个独立容器之间的通信. 这种策略消除了在这些容器之间进行操作系统级路由的需要。</li>
<li><code>MacLan Driver</code>: 为容器分配MAC地址，使其在网络上显示为物理设备。</li>
<li><code>None Driver</code>: 对于此容器，禁用所有联网. 通常与自定义网络驱动程序一起使用. none不适用于群体服务。</li>
</ol>
</blockquote>
<h3><span id="docker-实践"> docker 实践</span></h3>
<p>首先先安装<code>docker</code>, 安装的环境可以是 <code>linux</code>, <code>mac ox</code>, <code>window</code>。 其中<code>mac ox</code>, <code>window</code>分别安装的是<code>docker for mac</code>, <code>doker for window</code> （具体 mac 和window 的版本还有要求可在官网查询）。其原理实际上只是在<code>mac</code>或者 <code>window</code>的环境上造了一个<code>linux</code>的环境，如下图所示：<br>
<img src="https://github.com/Rimin/rimin.github.io/blob/master/img/docker/3.png?raw=true" alt="image3"></p>
<p>这里以 <code>Mysql</code> + <code>NodeJs</code> 的服务为例，构建镜像并用<code>docker compose</code> 构建成容器集群。</p>
<h5><span id="搭建并启动mysql数据库容器服务"> 搭建并启动<code>Mysql</code>数据库容器服务</span></h5>
<ol>
<li>
<p>寻找镜像源（<a href="https://hub.docker.com/_/mysql?tab=tags" target="_blank" rel="noopener">镜像库地址</a>）及确定版本。</p>
</li>
<li>
<p>执行以下操作（5.7为版本号）：</p>
</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看本地镜像，就会发现：</li>
</ol>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker images</span><br></pre></td></tr></table></figure>
<p>镜像列表里已经有了 <code>mysql:5.7</code> 的镜像。<br>
<img src="https://github.com/Rimin/rimin.github.io/blob/master/img/docker/4.png?raw=true" alt="image4"></p>
<ol start="4">
<li>使用：可以在宿主机器中直接登录（注意，前提是宿主机已经安装mysql及可执行mysql命令），宿主机器可以直接连接该数据库。即以下操作：</li>
</ol>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> -p <span class="number">3306</span>:<span class="number">3306</span> mysql:<span class="number">5.7</span></span><br></pre></td></tr></table></figure>
<p>接着在宿主机登录容器中的 <code>mysql</code>：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  mysql -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  -P <span class="number">3306</span> -u root -p</span><br></pre></td></tr></table></figure>
<p>(然后输入密码，注意 -h和 -P需要写全，否则可能会报错)</p>
<h5><span id="构建node服务的相关镜像文件"> 构建Node服务的相关镜像文件</span></h5>
<p>开始自己构建镜像，这里推荐直接使用VS Code 的插件docker，安装好之后接着 <code>command + shift + p</code> 使用<code>docker add</code> 后面就会自动创建docker 配置文件。</p>
<p>如下，为Dockfile配置文件：<br>
关于Dockerfile的配置项，可以参考<a href="https://docs.docker.com/engine/reference/builder/#usage" target="_blank" rel="noopener">官方文档</a>。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">10</span>  </span><br><span class="line"><span class="keyword">ENV</span> NODE_ENV docker </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/app/myprojectname</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">"package.json"</span>, <span class="string">"package-lock.json*"</span>, <span class="string">"npm-shrinkwrap.json*"</span>, <span class="string">"./"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> npm run dev</span></span><br></pre></td></tr></table></figure>
<p>对该dockfile简单的说明如下：</p>
<blockquote>
<p><code>FROM node:10</code><br>
该服务所依赖的环境，如果你的docker已经有node:10的镜像，会直接拉取本地已有的镜像，若没有则会从dockerhub镜像库拉取,这里推荐可以使用极小版的 <code>node:10-alpine</code></p>
</blockquote>
<blockquote>
<p><code>ENV NODE_ENV docker</code> 设定环境变量</p>
</blockquote>
<blockquote>
<p><code>WORKDIR /usr/app/myprojectname</code><br>
设定你的项目在容器中的位置，一个容器可以看成是一个小的linux系统，所以我们可以在容器启动后通过命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it ecef8319d2c8 /bin/sh</span></span><br></pre></td></tr></table></figure>
<p>(ecef8319d2c8 是你的 container id)<br>
直接进入到项目目录下，也可以查看整个容器的文件目录情况。会发现就是一个小的，与外界隔离的linux系统。</p>
<blockquote>
<p><code>COPY [&quot;package.json&quot;, &quot;package-lock.json*&quot;, &quot;npm-shrinkwrap.json*&quot;, &quot;./&quot;]</code><br>
将本地目录下的指定的文件复制到上面设置的 WORKDIR的项目目录中</p>
</blockquote>
<blockquote>
<p><code>RUN npm install</code> 运行你需要运行的命令</p>
</blockquote>
<blockquote>
<p><code>COPY . .</code> :<code>.</code>代表当前目录，即将当前目录的文件复制到docker的项目根目录下。</p>
</blockquote>
<blockquote>
<p><code>EXPOSE 3001</code> 将端口号暴露出来，后续可直接在宿主机器通过 127.0.0.1:3001暴露出来</p>
</blockquote>
<blockquote>
<p><code>CMD npm run dev</code>  设置容器启动后运行的命令</p>
</blockquote>
<p>配置好dockerfile文件后, 在项目根目录使用命令：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t yourDockerImageName .</span><br></pre></td></tr></table></figure>
<p>(注意: 你的docker镜像的命名格式最好是 你想上传该镜像的镜像库的注册ID/镜像名， 否则可能会因为命名的不唯一而被拒绝上传)</p>
<p>build完之后可以运行你的镜像了。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">3000</span>:<span class="number">3000</span>  yourDockerImageName</span><br></pre></td></tr></table></figure>
<h6><span id="构建docker-compose"> 构建docker-compose</span></h6>
<blockquote>
<p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。在 Docker Compose 里，我们通过一个配置文件，将所有与应用系统相关的软件及它们对应的容器进行配置，之后使用 Docker Compose 提供的命令进行启动，就能一次性启动并管理多个相关联的容器。</p>
</blockquote>
<p>这里将上述的构建的mysql容器和node服务器的容器构建docker-compose.yml 配置文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">version</span>: '2.1'</span><br><span class="line"></span><br><span class="line"><span class="attribute">services:</span></span><br><span class="line">  web:</span><br><span class="line">    <span class="attribute">image</span>: </span><br><span class="line">    <span class="attribute">environment:</span></span><br><span class="line">      NODE_ENV: dev</span><br><span class="line">    <span class="attribute">volumes</span>: </span><br><span class="line">      - ./log:/usr/app/web/log</span><br><span class="line">    <span class="attribute">links:</span></span><br><span class="line">        - db</span><br><span class="line">    <span class="attribute">depends_on</span>: </span><br><span class="line">      - db</span><br><span class="line">    <span class="attribute">ports:</span></span><br><span class="line">      - 3001:3001</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">db:</span></span><br><span class="line">    image: mysql:5.7</span><br><span class="line">    <span class="attribute">volumes:</span></span><br><span class="line">      - db-data:/var/lib/mysql</span><br><span class="line">    <span class="attribute">environment:</span></span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123456</span><br><span class="line">    <span class="attribute">ports:</span></span><br><span class="line">      - 3306:3306</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">volumes:</span></span><br><span class="line">  db-data: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>关于docker-compose.yml的配置说明可以详细阅读<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">官网</a></p>
<p>其中比较难理解的：</p>
<ul>
<li>
<p>Volumes配置相关： 该选项是 <code>${YOUR LOCAL PATH}:{DOCKER'S ABSOLUTE PATH}</code>, 也即可以将宿主机的本地文件和容器的某个绝对路径下的文件共享。什么时候使用？可以在项目有需要存放持久数据文件的时候将本地或者ftp服务器上专门的文件存放位置映射到容器的文件存放目录中。</p>
</li>
<li>
<p>容器间通信相关:</p>
</li>
</ul>
<blockquote>
<p>使用 Dcoker 部署项目常常会生成很多个容器，这些容器默认只能通过 ip 地址进行访问，但新建一个容器所产生的 ip 地址是不可控的，docker 默认额模式是桥接模式，网络地址一般为：<code>172.17.0.0/16</code> 或 <code>172.18.0.0/16</code>, 比如一个主机中有两个容器，一个可能是<code>172.18.0.2/16</code>，另一个是<code>172.18.0.3/16</code>。(可以使用<code>docker network inspect b9a9b34d772</code> (你的container id) 查看ip)<br>
这就给容器之间通信带来了一定的麻烦。Docker 中使用 Network 来管理容器之间的通信，只要两个 Conteiner 处于同一个 Network 之中，就可以通过容器名去互相通信。</p>
</blockquote>
<p>在上述 docker-compose up运行之后，会:</p>
<ol>
<li>创建一个名为<code>myqpp_default</code>的网络。</li>
<li>使用web服务的配置创建容器，它以<code>web</code>这个名称加入<code>myqpp_default</code>的网络。</li>
<li>使用db服务的配置容器，它以<code>db</code>这个名称加入<code>myqpp_default</code>的网络。</li>
</ol>
<p>因此总结一下容器间互相通信的方式：</p>
<ul>
<li>方式一：可以通过使用容器的IP地址来通信。这种方式会导致IP地址的硬编码，不方便迁移，并且容器重启后IP地址可能会改变，除非使用固定的IP地址。</li>
<li>方式2： 可以通过宿主机的IP加上容器暴露出的端口号来通信。这种方式比较单一，只能依靠监听在暴露出的端口的进程来进行有限的通信。</li>
<li>方式3： 可以使用容器名，通过docker的link机制通信。这种方式通过docker的link机制可以通过一个name来和另一个容器通信，link机制方便了容器去发现其它的容器并且可以安全的传递一些连接信息给其它的容器。使用name给容器起一个别名，方便记忆和使用。即使容器重启了，地址发生了变化，不会影响两个容器之间的连接。例如，web这个服务可使用 webapp://db:3306 访问db容器。若有其他容器连接上述服务名为web的容器，可以使用 <a href="http://web:3001" target="_blank" rel="noopener">http://web:3001</a> 访问。<br>
当然，也可以使用别名：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web</span><br><span class="line">    links:</span><br><span class="line">        - "db:database"   // 使用别名</span><br></pre></td></tr></table></figure>
<ul>
<li>networks 配置相关：networks关键字用于指定自定义网络<br>
例如：加入已经存在的网络</li>
</ul>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">networks:</span></span><br><span class="line"><span class="symbol">  default:</span></span><br><span class="line"><span class="symbol">    external:</span></span><br><span class="line"><span class="symbol">      name:</span> my-pre-existing-network</span><br></pre></td></tr></table></figure>
<p>以下例子定义了front和back网络，实现了网络隔离。其中proxy和db之间只能通过app来实现通信。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">  proxy:</span></span><br><span class="line"><span class="symbol">    build:</span> ./proxy</span><br><span class="line"><span class="symbol">    networks:</span></span><br><span class="line">      - front</span><br><span class="line"><span class="symbol">  app:</span></span><br><span class="line"><span class="symbol">    build:</span> ./app</span><br><span class="line"><span class="symbol">    networks:</span></span><br><span class="line">      - front</span><br><span class="line">      - back</span><br><span class="line"><span class="symbol">  db:</span></span><br><span class="line"><span class="symbol">    image:</span> postgres</span><br><span class="line"><span class="symbol">    networks:</span></span><br><span class="line">      - back</span><br></pre></td></tr></table></figure>
<p>构建好之后只要在当前路径下使用命令就能启动docker-compose：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>
<h6><span id="总结docker-network相关"> 总结：docker network相关</span></h6>
<ul>
<li>
<p>bridge模式: 默认使用<code>bridge</code>模式, 为容器提供一个独立的网络环境，因此，若要和其他容器连接，可以使用上述的<code>link</code>和服务名的方法。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker<span class="built_in"> network </span>create my-net</span><br></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">create</span> <span class="comment">--name my-nginx \</span></span><br><span class="line">  <span class="comment">--network my-net \</span></span><br><span class="line">  <span class="comment">--publish 8080:80 \</span></span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure>
<p>断开连接</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker<span class="built_in"> network </span>disconnect my-net my-nginx</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>host模式：该模式会破坏docker容器的网络隔离，使得所有的集群中的容器都使用宿主机的host。但是该模式在docker for mac 和docker for window 下不生效，因此如果你想在这两种环境中连接其他该环境中的容器，可以使用 docker 特有的域名 <code>host.docker.internal</code> 作为宿主网络的域名。（因宿主机ip可能会经常变化）</p>
</li>
<li>
<p>overlay 模式：该模式适用于多个不同的docker进程间的容器通信。即有多个Docker host，希望能够通过Docker swarm连接起来。具体可以参考<a href="https://docs.docker.com/network/overlay/" target="_blank" rel="noopener">overlay network</a></p>
</li>
<li>
<p>macvlan 模式： 略</p>
</li>
</ul>
<h3><span id="注意的点"> 注意的点</span></h3>
<blockquote>
<p>Docker 容器启动时，默认会把容器内部第一个进程，也就是pid=1的程序，作为docker容器是否正在运行的依据，如果 docker 容器pid=1的进程挂了，那么docker容器便会直接退出。</p>
</blockquote>
<blockquote>
<p>Docker未执行自定义的CMD之前，nginx的pid是1，执行到CMD之后，nginx就在后台运行，bash或sh脚本的pid变成了1。<br>
所以一旦执行完自定义CMD，nginx容器也就退出了。</p>
</blockquote>
<p>因此，如果使用<code>pm2</code>来部署<code>node</code>服务, 或者使用<code>ngnix</code>来部署前端服务时，需要注意进程被自动退出问题：<br>
需要加上防止后台运行的设置如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start ./master.js --no-daemon  # pm2</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemon off;   # 关闭后台运行 ngnix.conf</span><br></pre></td></tr></table></figure>
<h3><span id="常用docker命令"> 常用docker命令</span></h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker ps // 查看正在运行的镜像</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  docker build -t yourimagename .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -it  -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0.18 /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker commit -a <span class="string">'username'</span> -m <span class="string">'test'</span> 7aa8647dcfb5 <span class="built_in">test</span>-app:<span class="built_in">test</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker tag <span class="built_in">test</span>-app mydockerapp/<span class="built_in">test</span>-app:<span class="built_in">test</span> // 修改tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it ecef8319d2c8 /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi 89bba6dbdd98  // 删除某个容器</span></span><br></pre></td></tr></table></figure>
<p>参考链接：</p>
<ul>
<li><a href="https://juejin.im/post/5d0737a86fb9a07f087095f2" target="_blank" rel="noopener">使用 Docker 部署 NodeJS + MongoDB 项目</a></li>
<li><a href="http://www.itmuch.com/docker/24-docker-compose-network/" target="_blank" rel="noopener">Docker系列教程24-Docker Compose网络设置</a></li>
<li><a href="https://birdben.github.io/2017/05/02/Docker/Docker%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89Docker%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" target="_blank" rel="noopener">Docker实战（二十七）Docker容器之间的通信</a><br>
等</li>
</ul>


                <hr>
                

                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2019/09/18/datdabasepool/" data-toggle="tooltip" data-placement="top" title="一次疑似数据库死锁问题的排查">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                
                <!--Gitalk评论start  -->
                
                <!-- Gitalk end -->
                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#docker" title="docker">docker</a>
                        
                          <a class="tag" href="/tags/#backend" title="backend">backend</a>
                        
                    </div>
                </section>
                
            </div>

        </div>
    </div>
</article>

<div id="lv-container" data-id="city" data-uid="MTAyMC80NTEzOS8yMTY1Ng==" style="width: 28%; margin: 0 auto;">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>



        <!-- Footer -->
        <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Rimin&#39;s Blog 2021 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>

<!-- Service Worker -->

    <script type="text/javascript">
        if(navigator.serviceWorker){
            // For security reasons, a service worker can only control the pages that are in the same directory level or below it. That's why we put sw.js at ROOT level.
            navigator.serviceWorker
                .register('/sw.js')
                .then((registration) => {console.log('Service Worker Registered. ', registration)})
                .catch((error) => {console.log('ServiceWorker registration failed: ', error)})
        }
    </script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://rimin.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '2620e69674d25088f870bef114e8ff89';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>

<script src="https://c.mipcdn.com/static/v1/mip.js"></script>
<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
    </script>
<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }
    generateCatalog(".catalog-body");
    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))
    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




        <a id="rocket" href="#top" class=""></a>
        <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
        <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
        <!-- Image to hack wechat -->
        <img src="/img/apple-touch-icon.png" width="0" height="0" />
         <!-- Migrate from head to bottom, no longer block render and still work -->
    </body>
</html>