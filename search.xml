<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker初识与实践]]></title>
    <url>%2F2020%2F02%2F16%2Fdocker%2F</url>
    <content type="text"><![CDATA[认识docker docker(github 地址), 是一个开放源代码软件项目，让应用程序部署在软件货柜下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间，来创建独立的容器。 虚拟机 VS docker 虚拟化技术大家比较熟悉的是虚拟机 所谓虚拟机，通常来说就是通过一个虚拟机监视器 ( Virtual Machine Monitor ) 的设施来隔离操作系统与硬件或者应用程序和操作系统，以此达到虚拟化的目的。 但是虚拟机有一个最大的弊端，就是性能低下。可以看以下这张图： docker的产生，为开发，测试，运维等带来了巨大额便利，不仅如此，由于当下是云计算时代，应用的开发也逐渐趋向服务化甚至微服务化，docker应用更加广泛。 口说无凭，可以看一下docker 官方对 Docker 在工作上带来的提升做了调查研究，分别从工作效率的提升和技术设计投入的减少等方面数据化了 Docker 所做出的突出贡献: docker 的核心技术 docker 的核心技术实现归结于此三大技术： NameSpace: 命名空间是 Linux 核心在 2.4 版本后逐渐引入的一项用于运行隔离的模块. 以进程为例，通过 PID Namespace,在这个空间中运行的进程，完全感知不到外界系统中的其他进程或是其他进程命名空间中运行的进程。于是，利用 PID Namespace，Docker 就实现了容器中隔离程序运行中进程隔离这一目标。 Contrl Group: 资源控制组 ( 常缩写为 CGroups ) 是 Linux 内核在 2.6 版本后逐渐引入的一项对计算机资源控制的模块。虚拟化除了制造出虚拟的环境隔离同一物理平台运行的不同程序之外，另一大作用就是控制硬件资源的分配，CGroups 的使用正是为了这样的目的。 Union File System： 是一种能够同时挂载不同实际文件或文件夹到同一目录，形成一种联合文件结构的文件系统。Docker 创新的将其引入到容器实现中，用它解决虚拟环境对文件系统占用过量，实现虚拟环境快速启停等问题。后面接触到docker volume(docker 数据卷)时，就会发现他们都存储在统一的目录如： /var/lib/docker/volumes/8d47f68f0aad71a7d091cb0904c827/_data,同时，文件的更新像git一样只是将修改的部分记录在案，再更新源文件，大大减少了存储空间的使用。 docker的核心组成 docker的四大核心概念的介绍 镜像： 所谓镜像，可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。 容器：如果把镜像理解为编程中的类，那么容器就可以理解为类的实例。在容器技术中，容器就是用来隔离虚拟环境的基础设施，而在 Docker 里，它也被引申为隔离出来的虚拟环境。 网络：在 Docker 中，实现了强大的网络功能，我们不但能够十分轻松的对每个容器的网络进行配置，还能在容器间建立虚拟网络，将数个容器包裹其中，同时与其他网络环境隔离。 数据卷： 在以往的虚拟机中，我们通常直接采用虚拟机的文件系统作为应用数据等文件的存储位置。为了保证数据的独立性，我们通常会单独挂载一个文件系统来存放数据。而在 UnionFS 的加持下，除了能够从宿主操作系统中挂载目录外，还能够建立独立的目录持久存放数据，或者在容器间共享。在 Docker 中，通过这几种方式进行数据共享或持久化的文件或目录，我们都称为数据卷 ( Volume )。 docker 实践 首先在安装docker, 安装的环境可以是 linux, mac ox, window。 其中mac ox, window分别安装的是docker for mac, doker for window （具体mac 和window 的版本还有要求可在官网查询）。其原理实际上只是在mac或者 window的环境上造了一个linux的环境。 这里以 较为复杂的Mysql + NodeJs 的服务为例，构建镜像并用docker compose 构建成容器集群。 搭建并启动Mysql数据库容器服务 寻找镜像源（镜像库地址）及确定版本。 在 执行以下操作（5.7为版本号）： 1$ docker pull mysql:5.7 查看本地镜像，就会发现： 1$ docker images 镜像列表里已经有了 mysql:5.7 的镜像。 使用：可以在宿主机器中直接登录（注意，前提是宿主机已经安装mysql及可执行mysql命令），宿主机器可以直接连接该数据库。 1$ docker run -d -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 mysql:5.7 接着： 1$ mysql -h 127.0.0.1 -P 3306 -u root -p (注意 -h和 -P需要写全，否则可能会报错)]]></content>
      <tags>
        <tag>docker</tag>
        <tag>backend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次疑似数据库死锁问题的排查]]></title>
    <url>%2F2019%2F09%2F18%2Fdatdabasepool%2F</url>
    <content type="text"><![CDATA[初次使用数据库连接相关的一个比较新的框架 Typeorm TypeORM是一个ORM框架，它可以运行在NodeJS、浏览器、Cordova、PhoneGap、Ionic、React Native、Expo和Electron平台上，可以与TypeScript和JavaScript (ES5, ES6, ES7)一起使用。 但是在项目中初次使用typeorm时遇到的一个是疑似数据库锁死问题。部署之后一切运转正常，但是经过一定时间的运行之后会在所有存在数据库操作的地方卡住。服务重启之后可以恢复正常。 于是开始排查问题，难点在于，这个问题难以复现，也就是不知道什么时候应用会卡住，且对部分接口做过简单的压力测试也没有复现。因此只能根据&quot;症状&quot;及现有知识去逐个分析排查问题的根源所在。 排查过程 猜测一： 数据库连接数过大？ 使用命令show full processlist 可以看出当&quot;卡住&quot;时，连接数并不大，但是我们的服务应用有10条和数据库的连接（IP地址相同端口号不同） 接着使用 show variables like 'max_connections' 实际上，数据库的最大连接数还有151，因此可以排除数据库连接数过多的问题。 猜测二： 数据库并发死锁？ 由于发生&quot;卡住&quot;的问题时并发量并不大，并且使用命令 show engine innodb status \G; 也并没有发现有数据库死锁导致的错误的日志。 另外使用 SHOW STATUS LIKE 'Table%'; 通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况。 由此也可以排除由于数据库发生死锁而导致的卡住的问题。 数据库端排查之后，确定问题应该是出在应用端，也就是发起数据库连接的服务应用。于是开始排查服务端哪里出了问题： 首先先来看看当 Node 服务端开启一个服务的时候发生了什么： 12345678910var http = require('http');var server = http.createServer();// 注册 request 请求事件server.on('request', function(request, response)&#123; console.log()&#125;)server.listen(8000, function()&#123; console.log('port 8000 is listening'); console.log(global);&#125;) 通过一个简单的开启一个 Node 服务器来看一下全局 global 对象： 实际上，就是一个 process 对象，pid 为 33334, 即一个进程。 而实际上，当Node 开启一个服务时，它开启了： 一个进程（One process） 一个线程（One thread） 一个事件循环（One event loop） 一个JS引擎实例 （ One JS Engine Instance） 一个NodeJs实例 （ One Node.js Instance） Node 运行在单线程上，并且在事件循环中同一时刻只有一个进程的任务被执行，每次同一时刻只会执行一段代码(多段代码不会同时执行)。这是非常有效的，因为这样的机制足够简单，让你在使用 JavaScript 的时候无需担心并发编程的问题。 所以，如果一个 NodeJs 服务进程中有多个数据库连接（通过不同端口）（如第一张图片所示），只可能是在一个应用进程中创建了多个数据库连接。 于是回到 typeorm 本身，typeorm 的使用实际上很简单（只是文档有点杂乱，不够完善，比较坑 😷），而且开启了一个连接后，服务中需要使用数据库操作都可以复用服务启动时的连接而无需重新创建。 简单的一个使用 typeorm 连接数据库的例子： 1234567891011121314151617181920import "reflect-metadata";import &#123;createConnection&#125; from "typeorm";import &#123;Photo&#125; from "./entity/Photo";createConnection(&#123; type: "mysql", host: "localhost", port: 3306, username: "root", password: "admin", database: "test", entities: [ Photo ], synchronize: true, logging: false&#125;).then(connection =&gt; &#123; // here you can start to work with your entities // 数据库连接后可以启动服务程序，connection 可设置在需要使用数据库的地方可复用&#125;).catch(error =&gt; console.log(error)); 首先，从Node应用进程的角度以及对typeorm的使用，都是一次Node服务会创建一个可复用的链接，并且使用mysql时，默认使用数据库连接池连接，connection pooling 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，即数据库连接池在初始化的过程中已经创建了若干数据库连接置于池内备用。因此对于需要频繁创建，释放连接引起的操作，能避免由此引起的大量的性能开销。 数据库连接池的作用主要在于 资源的重用 更快的响应速度 统一的连接管理（如根据预先的连接占用超时时的设定，强制回收被占用的连接） 但是对于不需要频繁创建连接及关闭的应用，一般一个服务程序应该只有一个连接。但是从 show full processlist 来看，当时创建了十个数据库连接，所以提出猜测。 猜测三：在使用 typeorm 的过程中创建了连接却没有释放超过连接池的最大连接数 通过仔细查阅文档，发现是在应用中使用了 querryRunner 但是却没有在使用之后释放 。 使用querryRunner 的简单示例： 12345678910111213const queryRunner = connection.createQueryRunner();// you can use its methods only after you call connect// which performs real database connectionawait queryRunner.connect();// .. now you can work with query runner and call its methodsawait queryRunner.query('select * from test_table');// very important do not forget to release query runner once you finished working with itawait queryRunner.release(); 一般来说，由于typeorm使用的是orm语法： 面向对象编程把所有实体看成对象（object），关系型数据库则是采用实体之间的关系（relation）连接数据。很早就有人提出，关系也可以用对象表达，这样的话，就能使用面向对象编程，来操作关系型数据库。 ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是&quot;对象-关系映射&quot;（Object/Relational Mapping） 的缩写。 ORM 语法支持的sql操作主要是CRUD, 即主要为增删查改。 但是对于比较复杂的操作，没有对应的语法，就需要使用sql 语句，queryRunner 模块就提供了这样一个功能。 但是官方文档并没有说明为何在使用之后需要释放，于是简单地从源码去验证是创建了新的数据库连接： 见 MysqlQueryRunner.ts#L68 及 MysqlDriver.ts#L661 可以看出 queryRunner 会从已创建的连接池中获取一条新的连接： 部分源码如下： 1234567891011121314151617181920212223242526272829 /** * Creates/uses database connection from the connection pool to perform further operations. * Returns obtained database connection. */// mysql driverQuerry connet 方法connect(): Promise&lt;any&gt; &#123; if (this.databaseConnection) return Promise.resolve(this.databaseConnection); if (this.databaseConnectionPromise) return this.databaseConnectionPromise; if (this.mode === "slave" &amp;&amp; this.driver.isReplicated) &#123; this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(connection =&gt; &#123; this.databaseConnection = connection; return this.databaseConnection; &#125;); &#125; else &#123; // master this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(connection =&gt; &#123; this.databaseConnection = connection; return this.databaseConnection; &#125;); &#125; return this.databaseConnectionPromise; &#125; 123456789101112131415161718192021/** * Obtains a new database connection to a master server. * Used for replication. * If replication is not setup then returns default connection's database connection. */ obtainMasterConnection(): Promise&lt;any&gt; &#123; return new Promise&lt;any&gt;((ok, fail) =&gt; &#123; if (this.poolCluster) &#123; this.poolCluster.getConnection("MASTER", (err: any, dbConnection: any) =&gt; &#123; err ? fail(err) : ok(this.prepareDbConnection(dbConnection)); &#125;); &#125; else if (this.pool) &#123; this.pool.getConnection((err: any, dbConnection: any) =&gt; &#123; err ? fail(err) : ok(this.prepareDbConnection(dbConnection)); &#125;); &#125; else &#123; fail(new Error(`Connection is not established with mysql database`)); &#125; &#125;); &#125; 每使用一次就创建了一次数据库连接，而 typeorm 默认的数据库连接池最大连接池就是10, 如果没有释放，就会使得连接数一直增加没有释放直到连接数最大值 10，从而出现卡死的现象（但是没有报错，个人认为应该加上报错的机制）。于是问题得到解决。 总结 typeorm 作为一个使用 typescript 开发的数据库连接操作封装库比较新，有可能有坑，文档不够完善也需要一定的学习成本，但是语法便捷易用，本身轻量，性能也有一定的保证。 问题的排查 有很多bug是线上的问题，生产环境出的问题实际上难以复现， 因此可以在保证线上运行正常的情况下先根据表象做出合理的推理，尽可能多地收集线索，分析整理，逐一排查攻克。]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node内部机制]]></title>
    <url>%2F2019%2F06%2F15%2Fnode%2F</url>
    <content type="text"><![CDATA[之前一篇 文章只是讲述了node的其中较浅层的事件机制。但是 当我们在启动一个 Node 服务的时候我们”做“了什么？ 众所周知，Node的强项是I/O密集型，为事件驱动型，当某个I/O执行完毕时，将以事件的形式通知执行 I/O 操作的线程，线程执行这个事件的回调函数。而弱项在于处理CPU密集型的任务，比如在内存中使用一个大的数据集进行复杂计算，它会阻塞掉其他进程的任务。同样的，当你在发起一个有 CPU 密集型任务的远程接口请求时，也同样会阻塞掉其他需要被执行的请求。 为了解决高并发的问题，我们所熟知的很多服务器多是多线程的模式，优点在于： 线程相对进程开销较小，且线程之间可以共享数据，并且利用线程池可以减少创建和销毁线程的开销。 缺点在于：过多的线程会导致消耗大量的时间在切换上下文中，所以大并发量时，还是无法做到强大的伸缩性。 Node.js 底层是 C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度，犹如&quot;针尖上的舞蹈&quot;，用一个线程，担负起了处理非常多的任务的使命。 当开启一个 Node 服务时，发生了什么？ 我们将一段简单的代码用于开启一个服务器： 12345678910var http = require("http");var server = http .createServer(function(req, res) &#123; res.writeHead(200, &#123; "Content-type": "text-plain" &#125;); console.log(global); res.end(); &#125;) .listen(8900); 通过一个简单的开启一个 Node 服务器来看一下全局 global 对象： 实际上，就是一个 process 对象，pid 为 33334, 即一个进程。 Process 是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息。官方文档提供了详细的说明。 process.env： 环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息 process.nextTick：这个在谈及 EventLoop 时经常为会提到 process.pid：获取当前进程id process.ppid：当前进程对应的父进程 process.cwd()：获取当前进程工作目录， process.platform：获取当前进程运行的操作系统平台 process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值 进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听 三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出 process.title 指定进程名称，有的时候需要给进程指定一个名称 除了线程，当开启了一个Node服务时，实际上开启了： One process: 一个 全局的process对象。 a process is a global object that can be accessed anywhere and has information about what’s being executed at a time. One thread: 单线程 （单线程就是一个进程只开一个线程） One event loop：一个事件循环， 这是 Node 最核心的一点，使得Node可以异步执行，以及拥有非阻塞 IO。 One JS Engine Instance：一个 JS 引擎实例。 One Node.js Instance： 一个NodeJs应用实例。 关于Node单线程的误区 虽说Node是单线程，但是实际上查看实际程序运行时的树形图： 那么，为什么一个服务，Node启动了不止一个进程呢？ 实际上： Node 中最核心的是 v8 引擎，在 Node 启动后，会创建 v8 的实例，这个实例是多线程的。 主线程：编译，执行代码。 编译、优化线程： 在主线程执行的时候，可以优化代码。 分析线程： 记录分析线程运行的时间，为Cranksharft优化代码执行提供依据。 垃圾回收的几个线程。 因此，所谓的Node单线程是指Javascript 的执行是单线程的，但JavaScript的宿主环境，无论是Node还是浏览器都是多线程的，因为libuv中类似线程池的概念，libuv会通过操作类似线程池的实现来模拟不同操作系统的异步调用。这对开发者来说是不可见的。 libuv是一个跨平台IO库，它结合了UNIX下的libev和windows下的IOCP的特性，最早由Node的作者开发，专门为 Node 提供多平台下的异步IO支持。Libuv本身由C++语言实现，Node中的非阻塞IO以及事件循环的底层机制都是由libuv实现的。 Node的异步调用实际上是由Libuv来支持的。而读文件等的实际操作是由Libuv来完成。 Node多进程 我们知道单线程会带来弊端： 无法利用多核CPU 错误会引起整个应用退出 针对以上两个比较棘手的问题的解决方案： 对于1： 一些管理工具比如pm2. forver等都可以实现创建多进程解决多核CPU的利用率问题。 -在V0.8之前，实现多进程可以使用child_process. 在v0.8之后，可以使用cluster 模块。通过主从模式，创建多个工作进程。 对于2： Nginx反向代理，负载均衡，开多个进程，绑定多个端口。 一些管理工具比如pm2(实际上也是使用cluster), forver等都可以实现进程监控，错误自动重启等。 开多个进程监听同一个窗口，使用Node提供的cluster模块。 参考： 深入理解Node.js 进程与线程 来，告诉你Node.Js究竟是什么？ Understanding Woker Threads in Nnode.Js]]></content>
      <tags>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 缓存机制]]></title>
    <url>%2F2019%2F06%2F13%2Fcache%2F</url>
    <content type="text"><![CDATA[在整个大的应用体系中，缓存是节省流量，快捷高效的一环。 缓存的分类 源服务端缓存：比如 Nginx、Apache 网络中缓存： 代理服务器缓存(共享缓存), 反向代理服务器缓存（网关缓存负载均衡, CDN） 浏览器缓存：HTTP 缓存、indexDB、cookie、localstorage 等等 优点&amp;缺点 使用缓存的优点： 请求更快 节省带宽 降低服务器压力 缺点 网站管理员特别希望知道网站的一举一动，比方说多少人访问，访问时间，而缓存会“隐藏”他们的用户，他们就无从得知到底谁访问了这个站点 （解决方法之一：可以选择页面上的一个小元素(或页面本身)，然后给这个元素一个适当的头信息使它是不可缓存。比如，你可以在每一个页面上引用一个1像素×1像素的不可缓存（如scr地址后面加个随机数Add）的透明图片。Referer头信息将会包含调用它的页面信息。即使这样也不能给出你用户的精确统计，并且对通过互联网访问的用户也不是很友好：产生不必要的流量，并强迫用户等待未被缓存的内容从网络上下载回来） 无法及时更新 http缓存机制 规则 消息包头 值/示例 类型 作用 缺点/局限/注意 新鲜度 Expires Mon, 15 Aug 2016 03:56:47 GMT response 启用缓存和定义缓存时间。告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求 (http1.0)该时间是相对服务器的，因此存在客户端和服务端时间上不一致的问题。 Cache-Control public response 任何路径的缓存者（本地缓存、代理服务器）均可缓存 private response 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。 no-cache response 告诉浏览器忽略资源的缓存副本，强制每次请求直接发送给服务器，拉取资源，但不是“不缓存” no-store response 强制缓存在任何情况下都不要保留任何副本 max-age response 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）&lt;客户端当前时间 min-fresh response 指示客户机可以接收响应时间小于当前时间加上指定时间的响应 max-stale response 指示客户机可以接收超出超时期间的响应消息 Pragma no-cache response http1.0中存在的字段，在http1.1已被抛弃，使用Cache-Control替代，但为了做http协议的向下兼容，很多网站依旧会带上这个字段 校验值 Last-Modified Mon, 15 Aug 2016 03:56:47 GMT response 标示这个响应资源的最后修改时间 只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间 。 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形（无法使用缓存）可以使用ETag If-Modified-Since Mon, 15 Aug 2016 03:56:47 GMT request 当资源过期时（使用Cache-Control标识的max-age）,其值为上次响应头的Last-Modified值，再次向web服务器请求时带上头If-Modified-Since。web服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），包括更新Last-Modified的值，HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304(无需包体，节省浏览)，告知浏览器继续使用所保存的cache 要配合Cache-Control使用 Etag “fd56273325a2114818df4f29a628226d” response 告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）如果有 Etag 字段，那么浏览器就会将本次缓存写入硬盘中,之后的缓存是from disk cache If-None-Match “fd56273325a2114818df4f29a628226d” request 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。 Etag/If-None-Match也要配合Cache-Control使用。需要注意的是分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败，Yahoo建议分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样，因为除了 last-modified、inode 也很难保持一致)。 浏览器缓存机制 分类： 强缓存： 浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器。 协商缓存： 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回（304），但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；若未命中请求，则将资源返回客户端，并更新本地缓存数据（200）。 强缓存与协商缓存区别：强缓存不发请求到服务器，协商缓存会发请求到服务器。 设置缓存 1&lt;META HTTP-EQUIV="Pragma" CONTENT="no-cache"&gt; 但是 仅有IE才能识别这段meta标签含义，其它主流浏览器仅识别“Cache-Control: no-store”的meta标签。 浏览器缓存位置 Service Worker： 运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS Memory Cache （读取内存中的数据） Disk Cache Push Cache： 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放 网络请求 机制 第一次请求： 再次发送请求时： 相关问题 我的图片缓存一个月后才到期，我现在就想变动怎么办？ 最有效的方法是修改链接，这样会从源服务器获取完整的新内容。请记住，调用图片的这个页面也会被缓存的，正因如此，我们需要让图片以及其他类似的静态资源易缓存，而页面呢可以随着自身的改变（例如改变了一个图片的URL地址Add）即时更新。 大公司的静态资源优化方案，基本上要实现这么几个东西： 配置超长时间的本地缓存 —— 节省带宽，提高性能 采用内容摘要作为缓存更新依据 —— 精确的缓存控制（对于修改的静态文件，资源，改变它的url或者说文件名） 静态资源CDN部署 —— 优化网络请求 更新资源发布路径实现非覆盖式发布 —— 平滑升级（先部署页面，再部署资源还是先部署资源，再部署页面问题） 我们可以将所有前端静态资源开启永久强缓存，每次版本发布都可以首先让静态资源全量上线，再进一步上线模板或者页面文件，再也不用担心各种缓存和时间间隙的问题了！ 我的页面是密码保护的，代理缓存是怎么处理的？ 如果人们通过缓存访问我的网站，我应该担心安全吗？ （答： SSL页面不会被代理服务器缓存，所以这个你不需要担心。但是，代理服务器就好非SSL页面请求以及URL抓取这口，你懂的，这是不安全的。无良的管理员可能就会收集网站用户的信息，尤其在URL中） 参考： 详解web缓存 浏览器 HTTP 协议缓存机制详解 Web 开发人员需知的 Web 缓存知识 大公司里怎样开发和部署前端代码？]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>网络</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 概述]]></title>
    <url>%2F2019%2F06%2F13%2Fhttp%2F</url>
    <content type="text"><![CDATA[这篇博客主要介绍http协议相关的内容，总结了从浏览器的地址栏输入一个地址到获得请求的网页，经历了什么？以及对各版本http的特点进行总结。 从浏览器的地址栏输入一个地址到获得请求的网页，后端经历了什么？ 例如，我们键入： http://www.163.com,首先浏览器会将这个域名发送给DNS服务器，让它解析成IP地址。接着，因为HTTP是基于TCP的，因此要先建立TCP连接。于是三次握手四次挥手建立了TCP连接。（注意：目前使用的HTTP协议大多是1.1的在1.1里默认开启了Keep-Alive,这样建立的TCP连接，可以在多次请求中反复使用。) 接着我们拼凑起一个http请求报文。（通常包括：请求行，请求头，请求实体）。接下来交给Socket去发送，再交给TCP层。将报文二进制流变成一个个的报文发送。（在发送每一个报文的时候都需要对方回应一个ACK来保证报文到达，如果没有回应，那么TCP这一层会进行重新传输，知道可达，但是HTTP这一层不知道这点。）TCP在报文上加上自己的地址（原地址）和目标地址将这两个信息放至IP头，交给IP头传输。 IP层查看目标地址是否在同一个局域网，若时则发送ARP协议来请求这个目标地址的MAC地址，然后将源MAC地址和目标MAC地址放入MAC头交给链路层即可。若不在同一个局域网就发送到网关，计将源MAC地址和网关MAC地址放入MAC头发送出去。网关收到包发现MAC符合，取出目标IP地址，根据路由协议找到下一跳路由器获取下一跳路由器MAC地址，将包发送给下一跳路由器。 这样最终到达目标局域网，再到达目标地址。目标机器发现MAC符合，就将包收起来，发现IP地址符合再解析TCP头里面有序列号，看是否是所需要的，是就返回一个ACK,否则就丢弃。TCP头还有端口号，HTTP服务器正在监听这个端口号。于是目标机器知道是HTTP服务器这个进程想要这个包，就将包发送给HTTP服务器，HTTP进程拿到这个包后发现这是个要请求网页的请求包就将这个网页发送给客户端。 返回的过程类似。当浏览器拿到了HTTP报文，发现返回200，一切正常，于是就从正文中将HTML拿出来。后面浏览器就开始渲染这个网页。 （关于拿到这个网页后浏览器如何渲染，见浏览器内部机制） HTTP各版本协议间的区别及特点。 版本version HTTP1.0 HTTP1.1 HTTP2.0 连接 无连接，无法复用 长连接(Keep-Alive) 长连接 是否跟踪状态 无状态 跟踪状态 跟踪状态 其它特点 请求管道化 加入缓存处理(cache-control) 支持断点传输 增加Host字段如果第一个请求被堵塞了，则后面的请求即使处理完毕了，也需要等待 所有通信都在一个 TCP 连接上完成。支持服务器到客户端的主动推送机制 浏览器可以指定每个流的优先级，让服务器决定最优的响应次序 header压缩 二进制分帧 对HTTP头进行压缩 连接共享（分流，分帧（携带stream id辨识属于哪个请求流）解决队首阻塞,实现了真正的并行传输） 缺点 无法复用连接 无法并行（只能通过打开多个TCP会话) 多路复用（连接共享）可能会导致关键请求被阻塞 问题： 优先级问题（存在资源抢占）， 丢失重复发包问题 💡注： 由于http2的多路复用，合并请求显得不是很必要： 如：jS文件的合并。我们现在优化的一个主要方向就是尽量的减少HTTP的请求数， 对我们工程中的代码，研发时分模块开发，上线时我们会把所有的代码进行压缩合并，合并成一个文件，这样不管多少模块，都请求一个文件，减少了HTTP的请求数。但是这样做有一个非常严重的问题：文件的缓存。当我们有100个模块时，有一个模块改了东西，按照之前的方式，整个文件浏览器都需要重新下载，不能被缓存。现在我们有了HTTP/2了，模块就可以单独的压缩上线，而不影响其他没有修改的模块。 因此有关http2下的性能优化方案可能需有所调整。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法 http编码 ASCII码： http报文基于ASCII码（文本协议），原因：二进制协议可读性差，调试困难，对于一些数字，二进制传输Server是没法处理的。 base64： 一种基于64个可打印字符来表示二进制数据的编码方法。因为输入的字符可能有ASCII码中不可见字符，为完全可见，就用了base64编码。（二进制图片 → 文本） MIME： 能对包含文本、图像、音频、视频以及其他应用程序专用的数据 编码 举例用过的：text/html(超文本标记语言文本) image/gif image/jpeg text/plain (普通的文本) video/mpeg (MPEG文件) 注意： 如果直接使用http传输二进制的问题？不知道传输字节的具体长度。对于一些数字，二进制传输Server是没法处理的。可能会与终止符和冲突重复。 HTTP Header General Header Request URL Request Method Status Code Remote Address Referrer Policy(用于过滤 Referrer 报头内容): no-referrer-when-downgrade(当发生降级（比如从 https:// 跳转到 http:// ）时，不传递 Referrer 报头。但是反过来的话不受影响。通常也会当作浏览器的默认安全策略) Request Header Accept(能够接受的内容类型): */* text/plain, text/html Accept-Encoding（能够接受的编码类型）: gzip, deflate, br Accept-Language：zh-CN,zh;q=0.9 Accept-Ranges (可以请求网页实体的一个或者多个子范围字段): Accept-Ranges: bytes Authorization(HTTP授权的授权证书): Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control: max-age=2592000 Connection（表示是否需要持久连接。（HTTP 1.1默认进行持久连接））: keep alive Cookie：_ga=GA1.2.764928072.1522162861 Content-Length（请求的内容长度）：Content-Length: 348 Content-Type（请求的与实体对应的MIME信息）: text/plain; charset=utf-8 image/png application/x-www-form-urlencoded Date（请求发送的日期和时间）: Sun, 24 Mar 2019 08:20:11 GMT Expect(请求的特定的服务器行为): 100-continue From(发出请求的用户的Email): user@email.com Host (指定请求的服务器的域名和端口号): www.zcmhi.com If-Match If-Modified-Since If-None-Match Pragma（用来包含实现特定的指令）: no-cache Proxy-Authorization（连接到代理的授权证书）：Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range(只请求实体的一部分，指定范围): bytes=500-999 Referer（先前网页的地址，当前请求网页紧随其后,即来路） Upgrade： 向服务器指定某种传输协议以便服务器进行转换（如果支持）：HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 websorket User-Agent: Mozilla/5.0 (Linux; X11) Via(通知中间网关或代理服务器地址，通信协议): 1.0 fred, 1.1 nowhere.com (Apache/1.1) Response Accept-Ranges（表明服务器是否支持指定范围请求及哪种类型的分段请求）: bytes Age(从原始服务器到代理缓存形成的估算时间（以秒计，非负）): 12 Access-Control-Allow-Origin Access-Control-Allow-Credentials(表示是否可以将对请求的响应暴露给页面。返回true则可以，其他值均不可以。表示是否允许发送Cookie，跨域时客户端withCredentials 为 true 的请求会带上cookie) Access-Control-Allow-Headers Access-Control-Allow-Methods Access-Control-Max-Age Allow（对某网络资源的有效的请求行为，不允许则返回405）：GET, HEAD Cache-Control Content-Encoding: gzip Content-Language: en,zh Content-Length Content-Location(请求资源可替代的备用的另一地址): /index.htm Content-MD5(返回资源的MD5校验值):Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range(在整个返回体中本部分的字节位置): bytes 21010-47021/47022 Content-Type Date ETag Expires Last-Modified Location(用来重定向接收方到非请求URL的位置来完成请求或标识新的资源) Pragma Proxy-Authenticate(它指出认证方案和可应用到代理的该URL上的参数): Basic refresh(应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）): 5; url=http://www.zcmhi.com/archives/94.html Server(web服务器软件名称): Nginx Set-Cookie: io=pzIA1o986mOtUp5Xc0B5; Path=/; HttpOnly Trailer(指出头域在分块传输编码的尾部存在): Max-Forwards Transfer-Encoding(文件传输编码): chunked Vary(告诉下游代理是使用缓存响应还是从原始服务器请求): * Via http状态码 2xx 200 204: No content. 成功但响应报文不含实体的主体部分 205: Reset Content 成功但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容 206： Partial Content 进行范围请求 3xx 301： 永久重定向: 表示资源已被分配了新的 URL。搜索引擎机器人会在遇到该状态码时触发更新操作，在其索引库中修改与该资源相关的 URL 。举例： 网站重构， 更换域名，http迁移到https 302: 临时重定向: 由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。其他方法有可能会变更为 GET 方法.举例： 比如： 登录前先使用302重定向到登录页面,登录成功后再跳回到原来请求的页面。比如： 自动刷新页面，比如5秒后回到订单详细页面之类。 303： see other: 表示资源存在着另一个 URL，应使用 GET 方法获取资源。其他方法会变更为 GET 方法.(一些请求的处理会需要比较长的时间，比如有时候 DELETE 请求会被安排为稍后处理。在这种情况下，会返回一个 303 (See Other) 重定向响应，该响应链接到一个页面，表示请求的操作已经被列入计划，并且最终会通知用户操作的进展情况，或者允许用户将其取消。) 304: not modified 305: Use Proxy 使用代理。所请求的资源必须通过代理访问 307: temporary redirect.临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求。在这种情况下，搜索引擎不会更新它们的链接。当站点支持非 GET 方法的链接或操作的时候，该状态码优于 302 状态码。（也就是换个地址，重复对应的那个请求） 308: 与301类似，只不过是针对POST方法的请求不允许更改方法 4xx 400 bad request 请求报文存在语法错误 401 unauthorized 表示发送的请求需要有通过 HTTP 认证的认证信 403 forbidden 表示对请求资源的访问被服务器拒绝 404 not found 405 method not allowed 请求的方式（get、post、delete）方法与后台规定的方式不符合 415 后台程序不支持提交的content-type，就会返回415 5xx 500 internal sever error 501 Not Implemented 表示服务器不支持当前请求所需要的某个功能 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 service unavailable 表明服务器暂时处于超负载或正在停机维护，无法处理请求 504 gate way time out HTTP请求 简单请求 HEAD GET POST http头信息 Accept Accept-Language Content-Language Last-Event-ID Content-Type 非简单请求 预检请求： 比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json 浏览器跨域非简单请求头 字段包含 Access-Control-Request-Method Access-Control-Request-Headers（指定浏览器CORS请求会额外发送的头信息字段） X-Custom-Header 服务端做出响应 Access-Control-Allow-Origin: * Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age（用来指定本次预检请求的有效期，单位为秒）: 1728000 end 参考： 《趣谈网络协议》（刘超 极客时间） HTTP1.0 HTTP1.1 HTTP2.0 主要特性对比 合并HTTP请求 vs 并行HTTP请求，到底谁更快？ 谈谈 HTTP 连接管理 CORS预检请求详谈]]></content>
      <tags>
        <tag>HTTP</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JS DOM事件]]></title>
    <url>%2F2019%2F06%2F10%2Fdom%2F</url>
    <content type="text"><![CDATA[DOM 是针对HTML和XML文档定义的一个API, DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。DOM脱胎于 Netscape 及微软公司创始的 DHTML(动态HTML), 但现在它已经成为表现和操作页面标记的真正的跨平台、语言的中立的方式。 发展 dom0: 主要定义了HTML和XML文档的底层结构。在DOM0中，DOM由两个模块组成：DOM Core（DOM核心）和DOM HTML。 dom2: DOM视图（DOM Views）：定义了跟踪不同文档视图的接口 DOM事件（DOM Events）：定义了事件和事件处理的接口 DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口 DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口 dom3: DOM加载和保存模块（DOM Load and Save）：引入了以统一方式加载和保存文档的方法 DOM验证模块（DOM Validation）：定义了验证文档的方法 DOM核心的扩展（DOM Style）：支持XML 1.0规范，涉及XML Infoset、XPath和XML Base DOM2级和3级的目的在于扩展DOM API以满足操作XML的所有需求同时提供更好的错误处理及特性检测能力 事件对象 DOM中的事件对象 IE中的事件对象 可以看出还是有很大差别的，因此未来做到兼容，可以像类似下面这个函数 12345678910111213141516171819202122232425262728var EventUtil = &#123; addHandler: function (element, type, handler)&#123; // some code &#125;, getEvent: function (event) &#123; return event ? event : window.event &#125;, getTarget: function (event) &#123; return event.target || event.srcElement &#125;, preventDefault: function (event) &#123; if(event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false &#125; &#125;, removeHandle: function(element, type, handler)&#123; // some code &#125;, stopPropagation: function(event)&#123; if(event.stopPropagation) &#123; event.stopPropagation() &#125; else &#123; event.cancelBubble = true &#125; &#125;&#125; 事件处理 DOM0级事件处理： dom0级事件会覆盖，即只能添加一个事件 将一个函数赋值给一个事件处理程序属性。简单且具有跨浏览器优势。 1234var btn = document.getElementById('btn');btn.onclick = function() &#123; console.log(this.id) // "btn"&#125; DOM2级事件处理程序：定义了两个方法，好处是可以添加多个事件处理程序。 addEventListener() 只能用下面的方法移除 removeEventListener() 123456789btn.addEventListener('click', function()&#123; console.log(this.id);&#125;, false); // 表示在冒泡阶段调用该函数btn.addEventListener('click', function()&#123; console.log("another event function of btn execute");&#125;, false); // 表示在冒泡阶段调用该函数// 按顺序执行// 匿名函数无法移除 如果给一个body中的子节点同时注册冒泡和捕获事件，事件触发会按注册的顺序执行 event.stopImmediatePropagation和 event.stopImmediatePropagation作用在当前节点以及事件链上的所有后续节点上，目的是在执行完当前事件处理程序之后，停止当前节点以及所有后续节点的事件处理程序的运行 stopPropagation的在执行完绑定到当前元素上的所有事件处理程序之后，停止执行所有后续节点的事件处理程序 IE事件处理程序: 均添加到冒泡阶段 attachEvent() detachEvent() 1234btn.attachEvent('onclick', function() &#123; console.log(this.id) // undefined console.log(this) // window &#125;); 注意和dom0级和dom2级事件处理程序的区别在于作用域。以及在添加多个事件处理程序时不是按顺序执行，而是以相反的顺序执行。(这里的顺序是《JavaScript高级程序设计》中的，但是经过实验发现ie10,ie9是按顺序的，而ie8以下才按相反顺序) 注意：只有DOM2级事件规定事件包括三个阶段： 1. 事件捕获阶段 2. 处于目标阶段 3. 事件冒泡阶段 例子： 123456789101112131415161718192021222324252627&lt;body&gt;&lt;div id="p"&gt; parent &lt;div id="c"&gt; child &lt;/div&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; var p = document.getElementById('p'), c = document.getElementById('c'); c.addEventListener('click', function () &#123; alert('子节点捕获') &#125;, true); c.addEventListener('click', function () &#123; alert('子节点冒泡') &#125;, false); p.addEventListener('click', function () &#123; alert('父节点捕获') &#125;, true); p.addEventListener('click', function () &#123; alert('父节点冒泡') &#125;, false); &lt;/script&gt;&lt;/body&gt; 区别总结 dom0级 只能在冒泡阶段触发 只能绑定一个事件函数 事件函数this 指向被点击的元素本身 通过置空onclick属性解绑事件 dom2级事件 非ie: 可绑定多个事件函数 事件函数this 指向被点击的元素本身 多个事件函数的书法顺序和绑定顺序一样 ie 事件函数this属性引用全局对象,因此要用 window.event 多个事件函数的书法顺序和绑定顺序相反 dom3级事件： 规定了以下几种事件： UI事件当用户与页面上的元素交互时触发 焦点事件当元素获得或者失去焦点时触发 鼠标事件当用户通过鼠标在页面上执行操作时触发 滚轮事件当使用鼠标滚轮或类似设备时触发 文本事件当在文档中输入文本时触发 键盘事件当用户通过键盘在页面上执行操作时触发 合成事件当为IMEInput Method Editor输入法编辑器输入字符时触发 变动事件当底层Dom结构发生变化时触发 定义了自定义事件自定义事件不是由DOM原生触发的它的目的是让开发人员创建自己的事件 事件委托（代理） 事件委托利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 优点： 提高document对象访问效率 在页面中事件处理程序所花的时间少 整个页面占用内存空间更少，能够提高整体性能。 动态添加的元素无需额外注册事件。 删除的元素无需注销事件，因为一般如果元素注册了事件删除后需手动删除以回收内存 缺点（局限） 事件冒泡的过程也需要耗时，越靠近顶层，事件的”事件传播链”越长，也就越耗时 只能用于会冒泡的事件中，比如focus和blur本身是不会冒泡的 mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 123456&lt;div id="box"&gt; &lt;input type="button" id="add" value="添加" /&gt; &lt;input type="button" id="remove" value="删除" /&gt; &lt;input type="button" id="move" value="移动" /&gt; &lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt; 12345678910111213141516171819202122232425window.onload = function()&#123; var oBox = document.getElementById("box"); oBox.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input')&#123; switch(target.id)&#123; case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; &#125; &#125; &#125; &#125;// 通过绑定事件到父元素上再因为冒泡而判断target来判断点击的是哪个子元素 参考： 《JavaScript高级程序设计》 js中的事件委托或事件代理详解 JavaScript 事件委托详解]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全相关]]></title>
    <url>%2F2019%2F06%2F05%2Fsafe%2F</url>
    <content type="text"><![CDATA[安全对于一个系统网站来说是十分重要的，需要在项目架构的时候就考虑进去，虽然安全的工作主要还是得靠服务端，例如 ddos攻击，广告注入，http 劫持， 网络，服务器的架设也是十分关键的一环。 当然前端作为其中的一环，与用户最直接接触，也需要注意安全相关的问题。 前端最主要的两个攻击手段是 XSS(跨站脚本攻击) 和 CSRF (跨站请求伪造) XSS XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。 存储型 XSS 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作 常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等 反射型 XSS 攻击者构造出特殊的 URL，其中包含恶意代码 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 常见于通过 URL 传递参数的功能，如 网站搜索、跳转等 预防手段 输入过滤，转义（因非法字符无法穷举，因此可以使用白名单） 对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤 DOM 中的内联事件监听器，如 location, onclick、onerror、onload、onmouseover 等， 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。 输入内容长度控制 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 CSRF CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作，有很大的危害性。 这一个攻击过程可以用这样一个例子来阐述： 1. 受害者登录 a.com，并保留了登录凭证（Cookie）。 2. 攻击者引诱受害者访问了 b.com。 3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie 。 4. a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 5. a.com 以受害者的名义执行了 act=xx 。 6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。 特点： 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 预防 阻止不明外域的访问 同源检测 Origin Header Referer Header（Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞） Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token（目前很多网站采用Encrypted Token Pattern方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。这种Token的值通常是使用UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。） 双重Cookie验证（在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。）]]></content>
      <tags>
        <tag>Broswer</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承的5种实现方式]]></title>
    <url>%2F2019%2F05%2F04%2Finherite%2F</url>
    <content type="text"><![CDATA[1. 通过原型链的继承 1234567891011function SuperClass()&#123; this.name = 'jack'; this.age = 12;&#125;SuperClass.prototype.sayhi = function() &#123; console.log('hi, i am '+ this.name)&#125;function SubClass() &#123;&#125;SubClass.prototype = new SuperClass();var obj = new SubClass() 2. 通过call实现继承 1234567891011function SuperClass(name, age)&#123; this.name = name; this.age = age;&#125;SuperClass.prototype.sayhi = function() &#123; console.log('hi, i am '+ this.name)&#125;function SubClass(name, age) &#123; SuperClass.call(this, name, age) &#125;var obj = new SubClass('ken', 23) 3. 组合继承 1234567891011121314151617181920// 组合继承function SuperClass(name, age)&#123; this.name = name; this.age = age;&#125;SuperClass.prototype.sayhi = function() &#123; console.log('hi, i am '+ this.name)&#125;function SubClass(name, age, sex) &#123; SuperClass.call(this, name, age) this.sex = sex&#125;SubClass.prototype.getName = function() &#123; console.log(this.name)&#125; SubClass.prototype = SuperClass.prototype // SubClass.prototype = new SuperClassSubClass.prototype.constructor = SubClassvar obj = new SubClass('ken', 23, 0) 4. 寄生继承 1234567891011121314151617function SuperClass(name, age)&#123; this.name = name; this.age = age;&#125;SuperClass.prototype.sayhi = function() &#123; console.log('hi, i am '+ this.name)&#125;function SubClass(name, age, sex) &#123; SuperClass.call(this, name, age) this.sex = sex&#125;SubClass.prototype = Object.create(SuperClass.prototype,&#123; constructor: &#123; value: SubClass &#125;&#125;)var obj = new SubClass('ken', 23, 0) 5. ES6 1234567891011121314class SuperClass &#123; construtor(name, age) &#123; this.name = name; this.age = age; &#125; &#125;class SubClass extends SuperClass &#123; constructor(name, age, num) &#123; super(name, age) this.num = num &#125;&#125;var instance1 = new SubClass("1", 20, 1) 问： ES5/ES6 的继承除了写法以外还有什么区别？ 可以从这个例子中可以看出区别在于 子类能否寻找到继承的父类 123456class Super &#123;&#125;class Sub extends Super &#123;&#125;const sub = new Sub();Sub.__proto__ === Super; // true 1234567891011function Super() &#123;&#125;function Sub() &#123;&#125;Sub.prototype = new Super();Sub.prototype.constructor = Sub;var sub = new Sub();Sub.__proto__ === Super.prototype; // falseSub.__proto__ === Function.prototype; // true]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些概念]]></title>
    <url>%2F2019%2F05%2F02%2Fconcept%2F</url>
    <content type="text"><![CDATA[Json JavaScript Object Natation, JavaScript对象的表现形式，已经发展成一种轻量级的数据交换格式。JavaScript对象的表现形式，指定义JS对象的一种方式。数据交换格式，即用于交换的数据格式。（。XML也是一种数据交换格式，为什么没有选择XML呢？因为XML虽然可以作为跨平台的数据交换格式，但是在JS(JavaScript的简写)中处理XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而JSON没有附加的任何标记，在JS中可作为对象处理，所以我们更倾向于选择JSON来交换数据。 ） XML 可扩展标记性语言，计算机之间可以处理包含各种的信息比如文章等。它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。 HTML 超文本标记语言(Hyper Text Markup Language)，标准通用标记语言下的一个应用。HTML 不是一种编程语言，而是一种标记语言 (markup language) HTML vs XML XML 被设计为传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 被设计用来显示数据，其焦点是数据的外观。 HTML5 HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。设计目的是为了在移动设备上支持多媒体。HTML5的改进主要表现在：新元素，新属性, 完全支持 CSS3, Video 和 Audio,2D/3D 制图,本地存储,本地 SQL 数据, Web 应用。 ECMAScript 是一种由Ecma国际(前身为欧洲计算机制造商协会,European Computer Manufacturers Association)通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。 ECMAScript是JavaScript的核心或者说标准。它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象。 DTD文档声明 由于HTML有很多版本的规范，每个版本的规范都有差异，为了让浏览器能够正确的编译渲染我们的网页，我们需要在网页的第一行告诉浏览器，我们当前的网页用的是哪一个版本的规范 (虽然DTD文档声明的作用是告诉浏览器我们的网页是遵循了哪一套规范，每个浏览器都有他自己的机制，就算没有写明，也能正常编译，解析，渲染，显示网页) (html5的文档规范兼容所有的版本的规范) 待续…]]></content>
      <tags>
        <tag>Concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs 事件循环机制]]></title>
    <url>%2F2019%2F05%2F01%2FeventLoop-node%2F</url>
    <content type="text"><![CDATA[上一篇 主要是Js的事件机制，但是 Node 的时间循环机制和JS本身并不相同。 The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible. (NODE的事件循环就是允许Node执行非阻塞I/O操作，尽管js本身是单线程的，但是通过尽可能地将操作卸载至核心系统) ——node 官方文档 由于我们知道Javascript是单线程的，所以按常识很容易理解为什么它不能充分利用多核CPU。事实上，在Node中Javascript是单线程的之外，Node自身其实是多线程的，只是I/O线程使用的CPU较少。另外，除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）则是可以并行起来的。 Node.js 采用事件驱动和异步 I/O 的方式，实现了一个单线程、高并发的 JavaScript 运行时环境.除了 主线程 Node.js在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。 当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop) node异步I/O （图片来自《node深入浅出》朴灵） 这幅图大概就可以概括node的异步I/O运行机制。 但是这里node的I/O异步机制不作重点讨论，因为I/O的涉及到操作系统，node C++模块等较为底层的东西，这里暂不做讨论。 非I/O异步 在 node 中实现异步可以有 setTimeout和setInterval与浏览器中的API一致。 process.nextTick() setImmediate() 先看这幅图 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。 各个阶段分析 timers: executes callbacks scheduled by setTimeout() and setInterval(). (这个阶段执行setTimeout()和setInterval()设定的回调。一个timer指定一个下限时间而不是准确时间，在达到这个下限时间后执行回调。在指定时间过后，timers会尽可能早地执行回调，但系统调度或者其它回调的执行可能会延迟它们)。 pending callbacks: Executes I/O callbacks deferred to the next loop iteration。 This phase executes callbacks for some system operations such as types of TCP errors ( 执行延迟到下一个循环迭代的I / O回调, 注意是延迟的I/O回调， 这个阶段会执行一些错误的回调如TCP错误) idle, prepare: only used internally（仅仅内部使用）. poll： Retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and setImmediate()); Node will block here when appropriate。（获取新的I/O事件，执行I/O相关事件除了close callbacks, timers的回调， 和setImmediate()的回调） 这个阶段有两个函数： 1. 计算它应该在这里阻塞多久以及对I/O进行轮询，然后 2. 处理poll里的事件 - 如果 `poll `队列不空，`event loop`会遍历队列并同步执行回调，直到队列清空或执行的回调数到达系统上限 - 如果` poll `队列为空，则发生以下两件事之一： 0 ) 如果代码已经被`setImmediate()`设定了回调, `event loop`将结束` poll 阶段`进入` check` 阶段来执行 `check 队列`（里的回调） 1 ) 如果代码没有被`setImmediate()`设定回调`，event loop`将阻塞在该阶段等待回调被加入 `poll` 队列，并立即执行。 一旦 the poll queue 为空，poll 会检查是否有 timers 事件已到达时间，如果有，就会返回timers phase 去执行回调 check: 执行setImmediate()设定的回调。这个阶段允许在 poll 阶段结束后立即执行回调。如果 poll 阶段空闲，并且有被setImmediate()设定的回调，event loop会转到 check 阶段而不是继续等待。 setImmediate() is actually a special timer that runs in a separate phase of the event loop. It uses a libuv API that schedules callbacks to execute after the poll phase has completed.(setImmediate实际上是一个运行在node特定阶段的特殊的定时器， 它使用libuv API， 且在poll阶段结束后触发) close： 执行比如socket.on(‘close’, …)的回调。如果一个 socket 或 handle 被突然关掉（比如 socket.destroy()），close事件将在这个阶段被触发，否则将通过process.nextTick()触发。 接下来是一个例子： 1234567setTimeout(() =&gt; &#123; console.log('timeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('immediate');&#125;); 以上这个例子的执行结果实际上并不确定： 1234567$ node timeout_vs_immediate.jstimeoutimmediate$ node timeout_vs_immediate.jsimmediatetimeout 但是当你像下面这样： 12345678910const fs = require('fs');fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;, 0); setImmediate(() =&gt; &#123; console.log('immediate'); &#125;);&#125;); 就能确定运行结果为： 12immediatetimeout process.nextTick() 先看一个例子; 123456789101112131415161718process.nextTick(function () &#123; console.log('nextTick延迟执行1');&#125;);process.nextTick(function () &#123; console.log('nextTick延迟执行2');&#125;);// 加入两个setImmediate()的回调函数setImmediate(function () &#123; console.log('setImmediate延迟执行1'); // 进入下次循环 process.nextTick(function () &#123; console.log('process.nextTick 插入'); &#125;);&#125;);setImmediate(function () &#123; console.log('setImmediate延迟执行2'); &#125;);console.log('正常执行'); 1234567// node v0.10.13nextTick延迟执行1nextTick延迟执行2setImmediate延迟执行1process.nextTick 插入setImmediate延迟执行2 1234567// node v6.x正常执行nextTick延迟执行1nextTick延迟执行2setImmediate延迟执行1setImmediate延迟执行2process.nextTick 插入 123456789101112131415161718192021222324252627282930313233343536373839console.log(1)setTimeout(() =&gt; &#123; console.log(2) new Promise(resolve =&gt; &#123; console.log(4) resolve() &#125;).then(() =&gt; &#123; console.log(5) &#125;) process.nextTick(() =&gt; &#123; console.log(3) &#125;)&#125;)setTimeout(function () &#123; console.log(9); &#125;);new Promise(resolve =&gt; &#123; console.log(7) resolve()&#125;).then(() =&gt; &#123; console.log(8)&#125;)process.nextTick(() =&gt; &#123; console.log(6)&#125;)// 结果176824935 123456789101112131415161718192021222324252627282930313233343536373839console.log(1)setTimeout(() =&gt; &#123; console.log(2) new Promise(resolve =&gt; &#123; console.log(4) resolve() &#125;).then(() =&gt; &#123; console.log(5) &#125;) process.nextTick(() =&gt; &#123; console.log(3) &#125;)&#125;)setImmediate(function () &#123; console.log(9); &#125;);new Promise(resolve =&gt; &#123; console.log(7) resolve()&#125;).then(() =&gt; &#123; console.log(8)&#125;)process.nextTick(() =&gt; &#123; console.log(6)&#125;)// 结果176824359 实际上， process.nextTick()并没有出现在node事件循环的上述各个阶段中。 process.nextTick() is not technically part of the event loop.Instead, the nextTickQueue will be processed after the current operation is completed, regardless of the current phase of the event loop. Looking back at our diagram, any time you call process.nextTick() in a given phase, all callbacks passed to process.nextTick() will be resolved before the event loop continues. This can create some bad situations because it allows you to “starve” your I/O by making recursive process.nextTick() calls, which prevents the event loop from reaching the poll phase. ( process.nextTick()并不属于事件循环的一部分， nextTickQueue会在现有操作被完成后执行， 回头看那个事件阶段循环图， 如果在任何阶段都去执行process.nextTick, 那么有可能造成其他I/O回调等被“饿死”) 那么什么时候要用 process.nextTick() 呢？ Allow users to handle errors, cleanup any then unneeded resources, or perhaps try the request again before the event loop continues.（允许用户优先处理erroes等） At times it’s necessary to allow a callback to run after the call stack has unwound but before the event loop continues.(当必须要在当执行栈为空的时候立即去执行的回调时) 例如： 1234567891011121314151617const EventEmitter = require('events');const util = require('util');function MyEmitter() &#123; EventEmitter.call(this); // use nextTick to emit the event once a handler is assigned process.nextTick(() =&gt; &#123; this.emit('event'); &#125;);&#125;util.inherits(MyEmitter, EventEmitter);const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; &#123; console.log('an event occurred!');&#125;);]]></content>
      <tags>
        <tag>事件循环</tag>
        <tag>NodeJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 事件循环机制]]></title>
    <url>%2F2019%2F04%2F30%2FeventLoop%2F</url>
    <content type="text"><![CDATA[同步和异步 异步：简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 同步：相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 单线程 任务队列 因为js是单线程，任务需要排队，但是如果有一个任务要花费很长时间，这时后面的任务就会执行不了，造成阻塞，所以，设计者们意识到这个问题后，设计了一个方法：这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 “任务队列” 是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。主线程读取&quot;任务队列&quot;，就是读取里面有哪些事件。 “任务队列&quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列”，等待主线程读取。 ⚠️ 注意：在HTML Living Standard中描述到事件循环的步骤： An event loop has one or more task queues.（事件循环具有一个或多个任务队列） Let oldestTask be the oldest task on one of the event loop’s task queues Set the event loop’s currently running task to oldestTask Run oldestTask Set the event loop’s currently running task back to null Remove oldestTask from its task queue Microtasks: Perform a microtask checkpoint Update the rendering（重新渲染页面） If this is a worker event loop (i.e. one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below. Event Loop (图片来自Philip Roberts的演讲《Help, I’m stuck in an event-loop》) microtask 和 macroTask 在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取并且按优先级顺序执行，直到 microtasks 队列清空. 那么一般哪些会被推入macrotask,哪些会被推入microtask呢？ 12345- macrotasks: script (整体代码)，setTimeout, setInterval, setImmediate, I/O, UI rendering- microtasks: process.nextTick（node）, Promises, Object.observe(废弃), MutationObserver以上为按优先级排序 接下来看几个实例： 1234567891011121314151617181920console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');//执行结果：script startscript endpromise1promise2setTimeout ⚠️注意！由于the link between jobs &amp; microtasks is vague. 有关微任务的概念没有较为标准的规定，以及promises come from ECMAScript rather than HTML。ECMAScript has the concept of “jobs” which are similar to microtasks, but the relationship isn’t explicit aside from vague mailing list discussions。因此实际执行的顺序经过试验，chrom是最正确的，而其他包括FF,sfari,ie都有可能有出入。 再来看这个例子 12345678910111213141516171819202122232425262728293031323334353637 async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end') &#125; async function async2()&#123; console.log('async2') &#125; console.log('script start') setTimeout(function()&#123; console.log('setTimeout') &#125; ,0) async1(); new Promise(function(resolve)&#123; console.log('promise1') resolve(); &#125;).then(function()&#123; console.log('promise2') &#125;) console.log('script end')// 执行结果 // script start // async1 start // async2 // promise1 // script end // async1 end // promise2 // setTimeout 上面的 async 函数实际上是, 一个语法糖 1234567new Promise((resolve, reject) =&gt; &#123; console.log("async1 start"); console.log("async2"); resolve(Promise.resolve());&#125;).then(() =&gt; &#123; console.log("async1 end");&#125;); 墙裂推荐看这篇博文Tasks, microtasks, queues and schedules，里面的例子很经典（有坑）！！ ⚠️ We don’t process the microtask queue between listener callbacks, they’re processed after both listeners.]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自行实现call apply bind]]></title>
    <url>%2F2019%2F04%2F22%2Fcall%2Capply%2Cbind%2F</url>
    <content type="text"><![CDATA[call， apply，bind三者都是用于改变对象绑定的this的值，但是在用法上有一些略微的差别。 call （Function.prototype.call()） 例子： 12345678910111213function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.call(this, name, price); this.category = 'food';&#125;console.log(new Food('cheese', 5).name);//"cheese" 自行实现： 1234567function callFn(obj, ...arg)&#123; var _this = obj? obj || window; _this.fn = this; var res = _this.fn(...arg); delet _this.fn; return res;&#125; apply （Function.prototype.apply()） call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。 例子： 12345678910111213function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.apply(this, [name, price]); this.category = 'food';&#125;console.log(new Food('cheese', 5).name);//"cheese" 自行实现： 1234567function applyFn(object, array)&#123; var _this = obj? obj || window; _this.fn = this; var res = _this.fn(...array); delet _this.fn; return res;&#125; 注意： call的性能比apply的性能好，可以尽可能的去用call bind （Function.prototype.bind()） bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 注意： bind函数返回的是一个原函数的拷贝， 并拥有指定的this值和初始参数。 例子： 123456789101112131415function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; var fn = Product.bind(this, name, price); console.log(res); fn(); this.category = 'food';&#125;console.log(new Food('cheese', 5).name);//"cheese" 自行实现：(出自mdn) 1234567891011121314151617181920212223242526272829303132if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== 'function') &#123; // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() &#123;&#125;, fBound = function() &#123; // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用 return fToBind.apply(this instanceof fBound ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; // 维护原型关系 if (this.prototype) &#123; // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; &#125; // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; &#125;;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>自行实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JS对象和原型链]]></title>
    <url>%2F2019%2F04%2F21%2Fobject%2F</url>
    <content type="text"><![CDATA[什么是对象？ 对象是一组没有特定属性的值，对象的每一个属性或方法都有一个名字，而每一个名字都映射到一个值，其中值可以是数据或函数。每一个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是开发人员自定义的类型。 JavaScript中，一切都是对象，函数也是对象，数组也是对象，但是数组是对象的子集，而对于函数来说，函数与对象之间有一种“鸡生蛋蛋生鸡”的关 所有的对象都是由Object继承而来，而Object对象却是一个函数。对象都是由函数来创建的。 比如，在控制台中 输入 typeof Object 结果是&quot;function&quot;， 输入 typeof Function 结果还是&quot;function&quot; 虽然 JS 的对象和函数的关系看起来有点迷，但是也有自己的一套体系。 从创建对象来看 JS 创建对象有很多方式，在这里不一一列出，可以看一种原型方式： 1234567891011121314 function Person()&#123;//构造函数&#125;Person.prototype.name = "Nicholas";//添加原型属性Person.prototype.age = 29;Person.prototype.job = "software Engineer";Person.prototype.sayName = function() &#123;//添加原型方法 console.log(this.name);&#125;var person1 = new Person(); //实例化person1.sayName(); //“Nicholas”var person2 = new Person(); //实例化person2.sayName();//"Nicholas" 我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，(属性值是对象)而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。：prototype 通过 调用构造函数而创建的那个对象的原型对象。使用原型的好处可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息 添加到原型中。 上面的代码用图来反映： 对于[[Prototype]] 每一个对象都有一个这样的隐藏属性，它引用了创建这个对象的函数的prototype原型对象，我们来看一张图： 注意：函数也是对象，自然它也有__proto__。 在控制台中，我们发现： ⚠️⚠️ 这个指针没有标准的方法访问，IE 浏览器在脚本访问[[Prototype]]会不能识别，火狐和谷歌浏览器及其他某些浏览器均能识别。虽然可以输出，但无法获取内部信息。（[[Prototype]] 也可写为__proto__）虽然无法访问到，但是可以通过: Object.isPrototypeOf(person1)判断这个实例对象是否指向它的原型对象 ;而我们也知道Person.prototype就是Object类型，即一个原型对象. 123//承接上面的代码Person.prototype.isPrototypeOf(person1);//truePerson.prototype.isPrototypeOf(person2);//true 上面已经初略借助对象的创建来了解了原型链相关。接下来进行更深一步的探索。 原型创建对象机制 通过原型模式创建对象，我们接触到了对象创建的机制，如图： 12var o1 = new Object()var o2 = new Object() 接下来，再看另一种构造函数创造机制： 123function foo() &#123;&#125;var f1 = new foo()var f2 = new foo() 由于一切对象（除Object.prototype）都继承自Object,所以不难理解这里最大的boss是Object.prototype,而构造它的原型对象是null，这不是证明了它就是最大的boss吗？然而，并没有那么简单，那么，function()又是怎么回事呢？继续看： 我们知道，一切函数都是Function的实例，而参考点击这里 ，我们发现： Function 构造函数 创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个Function对象。 全局的Function对象没有自己的属性和方法, 但是, 因为它本身也是函数，所以它也会通过原型链从Function.prototype上继承部分属性和方法。 这句话“Function从Function.prototype上继承部分属性和方法”，可以解释 1Function.__proto__==Function.prototype 即可以说函数是由Function创建的，那么Function由自身创建，所以Function.__proto__就指向了创建它的函数（也就是自己）的prototype。 最后，再来一张总的图： 通过这张图我们就可以轻松知道： 12345678910Array.prototype // []Array.prototype.__proto__ // ObjectObject.prototype.__proto__ // nullObject.__proto__ // function ()&#123;&#125;Array.__proto__ // function ()&#123;&#125;Function.prototype.__proto__ // Object 函数与对象的关系，看来，最大的boss还是Object.prototype，因为从箭头的进出来看，Object.prototype是没有被谁创造出来的，而其他对象均可以找到创建它的原型对象。 原型链上的属性和方法 instanceof 判断原型和实例之间的关系 对于 A instanceof B来说，它的判断规则是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。 123456789101112131415// 手动实现 instanceof// 判断 obj1 是否 继承自obj2function isInstance(obj1, obj2)&#123; _pro = obj1.__proto__; pro = obj2.prototype; while(pro)&#123; if(_pro === pro) &#123; return true &#125; _pro = _pro.__proto__; &#125; return false&#125; ⚠️ typeof和instanceof的区别： typeof:会返回一个变量的基本类型，只有以下几种: number ,boolean,string,object,undefined,function,但是typeof在判断到引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。在 JS数据类型 中介绍了好几种方法对更细致的数据类型进行判断 instanceof 判断原型和实例之间的关系 原型链上的属性设置与屏蔽 我们已经知道原型链的搜索机制，那么假如我们人为地利用原型链改变对象之前的继承，即手动搭建原型链，会出现什么结果呢？ 比如： 12345678910111213141516171819function Sup()&#123; this.a = 1;&#125;Sup.prototype.fn1 = function()&#123; return true;&#125;function Sec()&#123; this.b = 2;&#125;Sec.protoype = new Sup();//继承了Sup()console.log(Sec.protoype.fn1);Sec.prototype.fn2 = function()&#123; return false;&#125;Sec.prototype.fn1 = function()&#123; return false;&#125;var instance = new Sec();console.log(instance.fn1); 实际上， 不管有没有改变其原来的继承，重写都会屏蔽,可以看这个例子 1234567891011121314151617function Sup()&#123; this.a = 1; &#125; Sup.prototype.fn1 = function()&#123; return true; &#125; function Sec()&#123; this.b = 2; &#125; Sec.prototype = new Sup(); Sec.prototype.fn2 = function()&#123; return false; &#125; Sec.prototype.a = 4; var instance = new Sec(); instance.c = 3; console.log(instance); 这里要注意的是，在添加属性时，原型链仍有一定的搜索机制，而不是直接添加： 如果属性c不是直接存于instance上，[[Prototype]]链就会被遍历，如果[[Prototype]]链上找不到c，c这时就会被直接添加到instance上。 然而，如果这时属性a存在于原型链上层而不存在于instance中，赋值语句instance.a = 4却不会修改到Sec.prototype中的a，而是直接把a作为一个新属性添加到了instance上 那么为什么在添加或修改时最终都是添加到是实例中，为何还要搜索，是因为可能存在着三种情况： 先来看一下代码（顺便我们转换一下思维，之前都是有构造函数后绑定原型.prototype，现在是有实例对象后绑定原型对象 .proto） 123456789101112var parentObject = &#123; a: 1, b: 2&#125;;var childObject = &#123;&#125;;childObject.__proto__ = parentObject;childObject.c = 3;childObject.a = 2;console.log(parentObject); // Object &#123;a: 1, b: 2&#125;console.log(childObject); // &gt; Object &#123;c: 3, a: 2&#125; 1234567891011121314151617var parentObject = &#123;&#125;;Object.defineProperty(parentObject, "a", &#123; value: 2, writable: false, // 标记为不可写 enumerable: true&#125;);var childObject = &#123; b: 3&#125;;childObject.__proto__ = parentObject; // 绑定原型childObject.a = 10; //试图改变console.log(childObject.a); // 2console.log(childObject); // &gt; Object &#123;b: 3&#125;console.log(parentObject); // Object &#123;a: 2&#125; 123456789101112131415var parentObject = &#123; set a(val) &#123; this.aaaaaa = val * 2; &#125;&#125;;var childObject = &#123; b: 3&#125;;childObject.__proto__ = parentObject;childObject.a = 10;console.log(childObject); // ?console.log(parentObject); // ? 结果是： 发现，10被当成参数传进原型对象中，而实例对象则得到对应的aaaaaa，这又该怎么解释呢？ 这就要了解一下set 函数了，这个set函数的运行机制就是如此。 所以就有这三种情况 如果在[[Prototype]]链上层存在名为a的普通数据访问属性，并且没有被标记为只读(writable: false)，那就会直接在childObject中添加一个名为a的新属性，它是屏蔽属性，这个情况就是上文例子中发生的情况。 如果在[[Prototype]]链上层存在a，但它被标记为只读(writable: false)，那么无法修改已有属性或者在childObject上创建屏蔽属性，严格模式下执行这个操作还会抛出错误。 如果在[[Prototype]]链上层存在a，但它被标记为只读(writable: false)，那么无法修改已有属性或者在childObject上创建屏蔽属性，严格模式下执行这个操作还会抛出错误。 如此一来，其添加或重写属性时就仍要按原型链搜索。 原型链上的constructot属性 constructor属性指向prototype属性所在函数 比如： 12345678function Foo() &#123; this.name = 'dog';&#125;Foo.prototype.constructor === Foo; // truevar a = new Foo(); a.constructor === Foo; // true 当a.constructor === Foo的时候，其实这时候并不能够说明a是由Foo构造而成的。实际上，a.constructor的引用是被委托给了Foo.prototype（本身a自身是没有这个属性的），所以才会出现等价的情况，而并不能说明a是由Foo构造而成的。 再看下面的代码： 12345678910111213function Foo() &#123; this.name = 'dog';&#125;Foo.prototype = &#123; // 字面量方法 h: 'hhh'&#125;;var a1 = new Foo();a1.constructor === Foo; // falsea1.constructor === Object; // truea1 instanceof Foo; //true 这里由于Foo.prototype的默认属性被清空了，所以constructor不存在，可是__proto__构成的原型链是不变的，所以a1.constructor的引用被委托到Object.prototype.constructor，所以第一个返回false，第二个返回true。 constructor作为原型链中的一环，会影响原型链的指向，但是它只是一个默认的属性，而且因为原型链是一个松散连接的结构，constructor并不安全。 对new操作符的认识 当执行new操作符时 创建一个全新的空对象 这个新对象会被执行[[prototype]]连接，使其沿着原型链依次继承各级原型对象的属性。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 将以上步骤拆解对比： 1234567891011121314151617181920212223242526272829303132function SuperType(name) &#123; // 定义了一个超类，供下面的子类继承 this.name = name;&#125;function SubType() &#123; // 定义了子类1，继承了超类，无返回值 SuperType.call(this, "Cong1"); this.age = 29; &#125;function SubType2() &#123; // 定义了子类2，继承了超类，返回了一个引用类型的值 SuperType.call(this, "Cong2"); this.age = 29; return &#123; a: 2 &#125;;&#125;function SubType3() &#123; // 定义了子类3，继承了超类，返回了一个值类型的值 SuperType.call(this, "Cong3"); this.age = 29; return 3;&#125;/* 下面比较有new操作符和无new操作符调用子类的区别 */var instance1_nonew = SubType();var instance2_nonew = SubType2();var instance3_nonew = SubType3();var instance1_hasnew = new SubType();var instance2_hasnew = new SubType2();var instance3_hasnew = new SubType3();// 依次打印六个变量console.log(…); 得到的结果： 123456789101112instance1_nonewundefinedinstance2_nonew&gt; Object &#123;a: 2&#125;instance3_nonew3instance1_hasnew&gt; SubType &#123;name: "Cong1", age: 29&#125;instance2_hasnew&gt; Object &#123;a: 2&#125;instance3_hasnew&gt; SubType3 &#123;name: "Cong3", age: 29&#125; 首先，从得到的结果来看，前三种情况很容易想到，因为只是将构造函数赋给另一个变量而已，当然得到它的返回值，而第四种情况也较常见，但是最后两种情况比较少见，总结一下： 首先新建一个对象： var instance = new Object() 给这个对象设置[[prototype]]链： instance.proto = SubType.prototype 绑定this，将SubType中的this指向instance，执行SubType中的语句进行赋值。 返回值，这里要根据SubType的返回类型来判断： 如果是一个引用类型（对象），那么就替换掉instance本身的这个对象。（如：instance2_hasnew） 如果是值类型，那么直接丢弃它，返回instance对象本身。（如：instance3_hasnew） （不过很少有在构造函数直接返回值的情况） 手动实现 new 操作： 123456function newOperation(SubType)&#123; var instance = new Object(); instance.__proto_ = SubType.prototype; let res = SubType.call(instance) return typeof res === "object" ? res : instance&#125; jquery之无new构建 最基本的创建对象的做法 1234567891011121314var jQuery = function () &#123; // 构造函数&#125;jQuery.prototype = &#123; version: '1.1.1', name: function() &#123; console.log(this.version); &#125;&#125;var a = new jQuery();a.name(); // "1.1.1" 但是，jquery 是没有 new 操作符的，那么如何不用 new 操作符呢？ 我们可能会想到这么做： 123456789101112var jQuery = function(selector, context) &#123; return new jQuery(selector, context);&#125;jQuery.prototype = &#123; name: function() &#123; // name方法 &#125;&#125;jQuery(); 然而，这里出现了死循环。 接下来，我们可能会这么做： 12345678910111213var jQuery = function (selector, context) &#123; return new jQuery.prototype.init(selector, context);&#125;jQuery.prototype = &#123; constructor: jQuery, init: function(selector, context) &#123; return this; &#125;, name: function () &#123; console.log("name调用"); &#125;&#125; 但是，这里JQuery.xxx会出错，因为明显所 new 的 jQuery.prototype.init中返回的this的指向已经被隐式修改。 所以，我们需要这么做： 1234567891011121314151617var jQuery = function (selector, context) &#123; return new jQuery.prototype.init(selector, context);&#125;jQuery.fn = jQuery.prototype = &#123; constructor: jQuery, init: function(selector, context) &#123; return this; &#125;, name: function () &#123; console.log("name调用"); &#125;&#125;jQuery.fn.init.prototype = jQuery.prototype;jQuery().name(); // name调用 其实我们把JQuery的 constrctor 和 prototype 都做了手动的控制，让它“伪造”成一个被我们自己new 出来的对象。 以上就是JS原型链和原型链的主要内容。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提升和它背后的机制]]></title>
    <url>%2F2019%2F04%2F19%2Fhoisting%2F</url>
    <content type="text"><![CDATA[变量提升 var 变量提升即将变量声明提升到它所在作用域的最开始的部分(这里就要先搞清楚它的作用域） 123456789101112(function()&#123; var a='One'; var b='Two'; var c='Three';&#125;)();//实际上它是这样子的(function()&#123; var a,b,c; a='One'; b='Two'; c='Three';&#125;)(); 1234567var scope="global"; function t()&#123; console.log(scope); //undefinded , scope声明覆盖了全局的scope,但是由于变量提升还没有赋值 var scope="local"; console.log(scope); //local&#125; t(); 由于有变量提升的问题，在写js code 的时候，我们需要把变量放在函数级作用域的顶端。 let 不存在变量提升 存在块级作用域 123456&#123; var a = 10; let b = 20; &#125;console.log(a); //10console.log(b); // ReferenceError: b is not defined let不允许在同一作用域内重复声明同一个变量 可以先声明后初始化 const 不存在变量提升 一旦声明常量，就必须同时初始化。不能先声明，后初始化 不允许在同一作用域内重复声明同一个变量 声明的常量不能改变，而修改对象的属性，并不会改变对象的地址，因此用const声明对象的属性是可以修改的 ⚠️⚠️注意 var 在全局作用域下声明的变量会挂载到全局window上，但是let 和 const 的不会!! 1234let len = 10;function fn() &#123; console.log(this.len);&#125; 函数提升 1234567function myTest()&#123; foo(); function foo()&#123; //函数提升 console.log("我来自 foo"); &#125;&#125;myTest(); 但是如果是这样则会产生错误： 1234console.log(sum(10,10));var sum = function(num1,num2)&#123; return num1+num2;&#125;; 因为函数位于一个初始化的语句中，是函数声明，而不是函数声明 同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用: 12345foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123;// ...&#125;; 这个代码片段经过提升后，实际上会被理解为以下形式： 1234567var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123;var bar = ...self...// ...&#125; 函数优先 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是函数会首先被提升，然后才是变量。 看一下代码： 123console.log(foo); //ƒ foo()&#123;&#125; var foo = 2;function foo()&#123;&#125;; 由此可以看出，同样会有提升，但是函数的提升会优先 背后的原理 为什么会存在变量的提升呢？内部的运行机制是怎么处理的？ 在真正解释执行之前，JavaScript解释器会预解析代码，将变量、函数声明部分提前解释： 运行代码来调用函数 在执行代码函数执行，先去创建上下文. 进入创建阶段 初始化作用域链 创建变量对象(VO) 创建arguments对象，检查当前上下文的参数，初始化名称和值并创建引用副本 扫描当前上下文的函数声明 扫描到来函数声明，那就在VO(variable object)里创建他的名称，并且指针是指向内存中函数引用的地址 如果扫描的函数声明已存在，那就覆盖VO中的引用指针 扫描当前上下文的变量声明 扫到变量声明，在VO中添加变量名称，并且初始化值是undefined 如果VO中存在变量名称，那就不做处理，继续扫描 确定当前上下文的this指向 激活/执行阶段 比如： 123456789101112// 上下文checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 可以看出为什么会出现提升且为什么函数可以优先提升。 1234567891011121314(function() &#123; console.log(typeof foo); console.log(typeof bar); var bar = function() &#123; return 'world'; &#125;; function foo() &#123; return 'hello'; &#125; var foo = 'hello';&#125;()); 最后，欢迎大家围观指正]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数据类型]]></title>
    <url>%2F2019%2F04%2F18%2FdataType%2F</url>
    <content type="text"><![CDATA[概述 js基本类型： Undefined、Null、Boolean、Number、String、Symbol js引用类型： Object (Object类型，Array类型，Date类型，Function类型，RegExp类型) 存储 基本数据类型占 8字节，存储在栈内存 如： 123456789101112131415var num1 = 5;var num2 = num1;|______|___|| | ||______|___|| num1 | 5 ||______|___||______|___|| num2 | 5 ||______|___|| num1 | 5 ||______|___| 引用类型变量只保存对对象，数组，和函数等引用类型的值得引用（即指针或者说内存地址），而引用类型的值保存在堆中 1234567891011121314151617181920var obj1 = new Objectvar obj2 = obj1obj1.name = 'Jack'console.log(obj2.name) // 'Jack' 栈 堆 _______________|______|_______| | |--------—| || | | _____\| | Obj1 | ||______|_______| / /| |name:jack| || obj1 | x0c01 |/ | --------- | |______|_______| |_______________| ________________|______|_______| | |--------—| || obj2 | x03c1 |--\ _____\| | Obj1 | ||______|_______| / /| |name:jack| || obj1 | x0c01 |/ | --------- | |______|_______| |_______________| 二进制浮点数 JavaScript 中的数字类型是基于“二进制浮点数”实现的, 64 bit , 8 字节 使用的是“双精度”格式。 浮点数值最高精度是17位小数，但在进行计算时其精确度远远不如整数。会有舍入误差 1234567891011var a = 0.1 + 0.2; // 结果是0.30000000000000004var b = 0.3;console.log(a === b); //falseconsole.log(Number.isInteger(a*10)); //falseconsole.log(Number.isInteger(b*10)); //trueconsole.log(a); //0.30000000000000004var f = 1.1f-- //0.10000000000000009 (由于浮点舍入错误所致) 数据类型的判别 NaN属于Number类型，并且 NaN不等于任何值，包括它自己 typeof: （判断不了引用类型）除了null都可以正确判断类型 12345typeof null // "object"/***为什么会出现这种情况呢？因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。****/typeof [1, 2, 3] // "object"typeof b // "undefined" 虽然没有第一但是还是会显示为undefined类型typeof NaN // "number" instanceof (通过原型链来判断) 123456(function ()&#123;&#125;) instanceof Function // true[1, 2, 3, 4] instanceof Array // truenew Number(1) instanceof Number // truenew Boolean(true) instanceof Boolean // truenew String('123') instanceof String // true 当然， 1[] instanceof Object; // true 因此，instanceof 只能用来判断对象类型，原始类型不可以，所有的对象类型instaceof Object 都是true constructor（通过构造器判断，但是没有绝对可靠性） Object.prototype.toString （这个方法只能判断 js 的内置数据类型） 1234567Object.prototype.toString.call(123) // "[object Number]"Object.prototype.toString.call('string') // "[object String]"Object.prototype.toString.call(true) // "[object Boolean]"Object.prototype.toString.call(Symbol(12)) // "[object Symbol]"Object.prototype.toString.call(&#123;&#125;) // "[object Object]"Object.prototype.toString.call([1,2,3]) // "[object Array]"Object.prototype.toString.call(function()&#123;&#125;) // "[object Function]" 通过 Object.getPrototypeOf(a) === Array.prototype 判断引用类型 Array.prototype.isPrototypeOf(a) 判断引用类型 1234var a = [];Array.prototype.isPrototypeOf(a); Object.getPrototypeOf(a) === Array.prototype; 数组还有一个方法，是es5新增的方法： 1Array.isArray() 类型转换 JavaScript是动态类型，变量是没有类型的，可以随时赋予任意值 js类型转换有显式和隐式转换，都会遵循一定的原理。 隐式转换 先来看下面的代码：😲 123456789&#123;&#125;+[] //0[] + &#123;&#125; // "[object Object]"var a = &#123;&#125;+[]console.log(a) // [object Object]console.log(typeof a) // string[] == false // true&#123;&#125; == true // true 条件判断： 在条件判断时，除了 undefined， null， false，NaN ， ''， 0， -0，其他所有值都转为 true，包括所有对象。 123if(undefined) &#123;console.log("false, 不执行")&#125;if([] || &#123;&#125;) &#123;console.log("true, 执行")&#125; 隐式转换原理判断 若想从源头出发，理解一些怪异的类型转换，就需要看 ECMA-262详细的规范,从而探究其内部原理,我们从这段内部原理示意代码开始： 原理代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ECMA-262, section 9.1, page 30. Use null/undefined for no hint,// (1) for number hint, and (2) for string hint.function ToPrimitive(x, hint) &#123; // Fast case check. if (IS_STRING(x)) return x; // Normal behavior. if (!IS_SPEC_OBJECT(x)) return x; if (IS_SYMBOL_WRAPPER(x)) throw MakeTypeError(kSymbolToPrimitive); if (hint == NO_HINT) hint = (IS_DATE(x)) ? STRING_HINT : NUMBER_HINT; return (hint == NUMBER_HINT) ? DefaultNumber(x) : DefaultString(x);&#125;// ECMA-262, section 8.6.2.6, page 28.function DefaultNumber(x) &#123; if (!IS_SYMBOL_WRAPPER(x)) &#123; var valueOf = x.valueOf; if (IS_SPEC_FUNCTION(valueOf)) &#123; var v = %_CallFunction(x, valueOf); if (IsPrimitive(v)) return v; &#125; var toString = x.toString; if (IS_SPEC_FUNCTION(toString)) &#123; var s = %_CallFunction(x, toString); if (IsPrimitive(s)) return s; &#125; &#125; throw MakeTypeError(kCannotConvertToPrimitive);&#125;// ECMA-262, section 8.6.2.6, page 28.function DefaultString(x) &#123; if (!IS_SYMBOL_WRAPPER(x)) &#123; var toString = x.toString; if (IS_SPEC_FUNCTION(toString)) &#123; var s = %_CallFunction(x, toString); if (IsPrimitive(s)) return s; &#125; var valueOf = x.valueOf; if (IS_SPEC_FUNCTION(valueOf)) &#123; var v = %_CallFunction(x, valueOf); if (IsPrimitive(v)) return v; &#125; &#125; throw MakeTypeError(kCannotConvertToPrimitive);&#125; 上面代码的逻辑是这样的： 如果变量为字符串，直接返回. 如果!IS_SPEC_OBJECT(x)，直接返回. 如果IS_SYMBOL_WRAPPER(x)，则抛出异常 否则会根据传入的hint来调用DefaultNumber和DefaultString，比如如果为Date对象，会调用DefaultString DefaultNumber：首先x.valueOf，如果为primitive，则返回valueOf后的值，否则继续调用x.toString，如果为primitive，则返回toString后的值，否则抛出异常 DefaultString：和DefaultNumber正好相反，先调用toString，如果不是primitive再调用valueOf. 比如： 1231 + &#123;&#125; // "1[object Object]"1 + [] // "1" {}和1首先会调用ToPrimitive {}会走到DefaultNumber，首先会调用valueOf，返回的是Object {}，不是primitive类型，从而继续走到toString，返回[object Object]，是String类型 最后加操作，结果为[object Object]1 再比如有人问你[] + 1输出啥时，你可能知道应该怎么去计算了，先对[]调用ToPrimitive，返回空字符串，最后结果为&quot;1&quot;。 四则运算符 + 有字符串，另一方也转换为字符串。如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 + - * /: 只要其中一方是数字，那么另一方就会被转为数字 比较运算符 x == y,其中x和y是值 若Type(x)与Type(y)相同，则 若Type(x)为Udefined,返回true 若Type(x)为Null, 返回true 若Type(x)为Number,则 若x为NaN, 返回false 若y为NaN, 返回false 若x与y为相等数值，返回true 若x为+0且y为-0，或x为-0且y为+0，返回true 若x为null且y为Undefined，返回true，反之同理，即null == undefined 若Type(x)为Number且Type(y)为String, 比较 x == ToNumber(y)的结果，反之同理 若 Type(x) 为Boolean，返回比较ToNumber(x) == y 的结果，反之同理 若Type(x) 为String或 Number且Type(y)为 Object,返回比较x == ToNumber(y)的结果,反之同理 返回 false 验证： 123456789'' == false // true'0' == false // ture[] == false // true'' == 0 // true'0' == 0 // true0 == [] // true'' == [] // truenull == undefined // true&#123;&#125; == true // true 显示转换 类型转换表 value string number boolean object undefined “undefined” NaN false throws TypeError null “null” 0 false throws TypeError true “true” 1 true new Boolean(false) false “false” 0 false new Boolean(false) “” 0 false new String(’’) 0 (-0) “0” false new Number(0) NaN ‘NaN’ false new Number(NaN) Infinity “Infinity” true new Number(Infinity) ‘’ 0 true [9] ‘9’ 9 true 例子： 12345678910111213141516171819202122232425262728293031323334Object(undefined) // &#123;&#125; 返回一个空对象Object(null) // &#123;&#125; 返回一个空对象var n = 123456.789n.toFixed(0) // "123457" n.toExponential(1) // "1.2e+5"n.toPrecision(5) // "1.2346e+5"n = 1000000000000000000000000000000parseInt(n) // 1 因为这里会将n先用科学计数法转换成 "1e+30" 然后再parseInt截断成 1n.toString() // "1e+30"[1,2,3].toString() // "1,2,3"var a = new Boolean(false) var b = new Number(0)var c = new String("")a &amp;&amp; b &amp;&amp; c // 1// a, b, c为假值对象a === false // false 这里由于类型不同，当然不相等a == false // true 这里不是严格相等，而是将他们进行转换后值相等var c = &#123; valueOf()&#123; return 123 &#125;, toString()&#123; return 456 &#125;&#125;Number(c) // 123 // 这个例子也说明了上面转换的原理。且可以改写 在 TypeScript中的应用 TypeScript 是 JavaScript 的一个超集（如果一个集合S2中的每一个元素都在集合S1中，且集合S1中可能包含S2中没有的元素，则集合S1就是S2的一个超集），主要提供了类型系统和对 ES6 的支持 可以在编译阶段就发现大部分错误，比在运行时候出错好 熟悉javascript的类型相关后，可以基于其学习 ts对其变量类型的定义规则 例子： 举例 1234567891011121314let isDone: boolean = false;let createdByNewBoolean: boolean = new Boolean(1); // 错误，属于对象let notANumber: number = NaN;let infinityNumber: number = Infinity;let binaryLiteral: number = 0b1010; =&gt; var binaryLiteral = 10; // 二级制编译成十进制let octalLiteral: number = 0o744; =&gt; var octalLiteral = 484; // 八进制编译成 十进制let u: undefined = undefined;let n: null = null; 123456789101112// 内置对象let b: Boolean = new Boolean(1);let e: Error = new Error('Error occurred');let d: Date = new Date();let r: RegExp = /[a-z]/;// DOM 和 BOM Document、HTMLElement、Event、NodeListlet body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click', function(e: MouseEvent) &#123; // Do something&#125;); 不同点： ts 新增了很多对类型的控制，它更像是一种代码类型规范约束手段或者说代码检查的工具。 比如 void， 接口（Interfaces) 类型断言 联合类型 字符串字面量类型,元组，枚举（Enum）类型 类的public、private 和 protected的定义等 PS: 初识typescript: 个人对 typescript的思考： 首先代码类型检查是一个很好的习惯, 平时在开发中应当多注意类型的判断，否则很有可能在一些公共组件中会有因为类型错误而无法运行出错的情况。但是因为只是静态类型的检测，因此还是避免不了一些类型错误，比如运行时。因此，个人感觉单靠typescript是无法解决所有类型变量出问题而出现Bug的情况。另外，代码的易读性会有所降低，重构成本和维护成本也会比较大。但是代码质量，特别是在团队合作时更能有保证。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2019%2F04%2F18%2FcrossOrign%2F</url>
    <content type="text"><![CDATA[什么是跨域？ 当前访问的服务器所返回的页面，页面内的JS访问另一个服务器的资源的时候，出现跨域。（本地资源打开的页面去访问服务器，也是跨域） 如何判断跨域？ 协议是否相同 域名是否相同 端口号是否相同 举例：http://www.example.com/dir/page.html, 这个url的协议：http,域名为：example.com，顶级域名:.com。主机名：www (也是三级域名)。端口是80（默认端口可以省略），它的同源情况如下： http://www.example.com/dir2/other.html : 同源 http://example.com/dir/other.html ：不同源 http://example.com:81/dir/other.html ：不同源 ⚠️ 注意：域名和域名对应ip算跨域 ⚠️ 注意：引入外链资源JS、IMG的时候没有跨域限制，Iframe也可以直接引入跨域页面，但无权限访问iframe 同源策略 来源： 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页&quot;同源&quot;。所谓&quot;同源&quot;指的是&quot;三个相同&quot;。 浏览器的同源策略限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。注意： 对于当前页面来说，页面内存放JavaScript文件的域并不重要，重要的是加载JavaScript页面所在的域是什么。 比如：a.com通过加载一下代码： 12&gt; &lt;script src=http://b.com/b.js &gt;&lt;/script&gt;&gt; 加载b.com上的b.js是运行在a.com页面上的，因此对于当前打开的页面（a.com页面）来说，b.js的Origin就应该是a.com而非b.com。 在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等标签都可以跨域加载资源，而不受同源策略的限制。这些带“src”属性的标签每次加载时，实际上是由浏览器发起了一次GET请求。不同于XMLHttpRequest的是，通过src属性加载的资源，浏览器限制了JavaScript的权限，使其不能读、写返回的内容。 在HTML5中，有些元素提供了支持CORS(Cross-Origin Resource Sharing)（跨域资源共享）的属性，这些元素包括&lt;img&gt;，&lt;video&gt;，&lt;script&gt;等，而提供的属性名就是crossOrigin属性。 目的 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，&quot;同源政策&quot;是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 限制行为 （1） Cookie、LocalStorage 和 IndexDB 无法读取。 （2） DOM 无法获得。 （3） AJAX 请求不能发送。 实现跨域的几种方法 iframe 如果两个网页不同源，就无法拿到对方的DOM，也无法进行通信。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 解决方法： document.domain（如果两个窗口一级域名相同，只是二级域名不同） 片段识别符（fragment identifier） 1234567891011121314//父窗口可以把信息，写入子窗口的片段标识符var src = originURL + '#' + data;document.getElementById('myIFrame').src = src;//子窗口通过监听hashchange事件得到通知window.onhashchange = checkMessage;function checkMessage() &#123; var message = window.location.hash; // ...&#125;//同样的，子窗口也可以改变父窗口的片段标识符parent.location.href= target + "#" + hash; window.name 无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。window.name容量很大，可以放置非常长的字符串.(ps:个人感觉也是一个小tip) window.postMessage （MessageChannel） 12var popup = window.open('http://bbb.com', 'title');popup.postMessage('Hello World!', 'http://bbb.com'); 12345//父窗口和子窗口都可以通过message事件，监听对方的消息。window.addEventListener('message', function(e) &#123; console.log(e.data);&#125;,false); AJAX 1. JSONP 特点：利用script标签实现跨域，兼容性好。 示例： 1234567891011121314151617181920212223242526// jsonpfunction jsonp(url, jsonpCallback)&#123; let script = document.createElement('script'); url = handleUrl(url) script.src = url window[jsonpCallback] = function(res)&#123; document.body.removeChild(script) delete window[jsonpCallback] console.log(res) &#125;&#125;/***@param &#123;String&#125; url *@param &#123;Object&#125; data**/function handleUrl(url, data)&#123; var keys = Object.keys(data); let params = keys.reduce((pre, cur, index) =&gt; &#123; const value = data[cur]; const slipt = index === keys.length - 1? '' : '&amp;' return `$&#123;pre&#125;$&#123;cur&#125;=$&#123;value&#125;$&#123;slipt&#125;` &#125;, '') return `$&#123;url&#125;?$&#123;params&#125;`&#125; url返回的即是将数据传入jsonpCallback并调用执行的脚本。而script标签会让它自动执行。 2. WebSocket WebSocket 教程—阮一峰 (websocket没有同源限制，客户端可以与任意服务器通信,顺便说一下它最大的特点，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。) 3. CORS CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 注意：普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置 12345// 前端设置是否带cookiexhr.withCredentials = true;// 后端设置是否携带cookie response.setHeader("Access-Control-Allow-Credentials", "true"); nginx代理跨域,node开启服务作为代理跨域 跨域原理： 同源策略只是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。]]></content>
      <tags>
        <tag>Broswser</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解闭包]]></title>
    <url>%2F2019%2F04%2F18%2F%20closure%2F</url>
    <content type="text"><![CDATA[函数的使用 1）普通用法 2）当值传递：也就是作为值来传递 3）函数作为返回值 以上就是函数常见的几种用法。 后面这两种情况就会涉及到闭包，因此还会详细讨论 123456789函数作为返回值function fn()&#123; var min = 10; return function compare(x)&#123; if(x&gt;max)&#123; console.log(x); &#125; &#125;&#125; 12345678910111213函数作为值传递function foo()&#123; var a = 2; function baz()&#123; console.log(a); &#125; bar(baz);&#125;function bar(fn)&#123; fn(); &#125;; foo(); //2 上下文执行环境和作用域 词法作用域（静态作用域） 词法作用域关心的是函数和作用域是如何声明以及在何处声明，而并不是动态作用域 123456789101112function foo() &#123; console.log(a); &#125; function bar() &#123; var a = 3; foo(); &#125; var a = 2; bar (); // 2 （这里打印出的是全局的2，可见，虽然foo()是在bar()中被调用的，但是由于foo()的作用域链是 foo()→全局，因此，并不会搜索到bar()中的a，而如果是动态作用域，就会搜索到bar中的a了。） 上下文环境 EC 1234567891011var a = 10;var fn;var bar = function(x)&#123; var b = 5; fn(x+b);&#125;;fn = function(y)&#123; var c = 5; console.log(y+c);&#125;;bar(10); 123 fn-上下文环境 bar-上下文环境 bar-上下文环境 bar-上下文环境全局上下文环境 -&gt; 全局上下文环境 -&gt; 全局上下文环境 -&gt; 全局上下文环境 -&gt; 全局上下文环境 一个完整的闭环，进栈设置为活动状态，也就是保存其上下文数据，出栈即被销毁其上下文数据，干脆利落，但是，后面要说到的闭包就不是这么干脆的说销毁就销毁了（垃圾回收）。 而对于上下文环境 EC 变量对象 VO :（Variable Object）保存此EC中涉及到的变量。 作用域链 ScopeChain: 此EC中的VO与其他EC中的VO的关联关系（能否访问到） this: 在EC被创建时，会确定this的指向 作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。 改变或延长作用域 改变可以用 apply()，call()，bind()这些函数 延长可以用 try-catch 语句的catch块，with语句 块级作用域 对于 ES5, 没有块级作用域，也就是花括号括起来的作用域，javascript除了全局作用域之外，只有函数可以创建的作用域 所以，在if,for语句中要特别注意。 比如： 12345var a = 10;if(a&gt;5)&#123; a = 4;&#125;console,log(a); //4 if语句里的a也是全局的 闭包 因为作用域链，外部不能访问内部的变量和方法，这时我们就需要通过闭包，返回内部的方法和变量给外部，从而就形成了一个闭包。 例子： 12345678910111213function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 上面这段代码，是函数作为返回值的情况，当foo()执行后，将bar函数赋值给baz,本来应该就跟foo没什么关系了，其上下文就应该会被销毁了，但是因为bar需要打印出a的值，而根据词法作用域，它要在它的作用域链（bar→foo→全局）中寻找，因此可以在foo中找到a，所以，foo()的内部作用域依然存在，因为bar()持有着对该作用域的引用，使得该作用域一直存活，以供bar()在之后的任何时间进行引用。 而这个引用就叫闭包。 123456789101112131415161718var fn;function foo() &#123; var a = 2; function baz() &#123; console.log(a); &#125; fn = baz; // 将baz分配给全局变量&#125;function bar() &#123; fn();&#125;foo();bar(); // 这里也是函数当成值来传递（间接传递），同样是闭包。 接下来，看看for循环的坑 1234567891011121314function fn()&#123; var arr = new Array; var i; for(i=0;i&lt;10;i++)&#123; arr[i] = function()&#123; return i; &#125; &#125; return arr;&#125; var array = fn(); for(var j=0; j&lt;10;j++)&#123; console.log(array[j]()); //10个10 &#125; fn函数执行后，返回了一个函数数组，这个数组包含10个会return i的函数，接下来让array执行，这时候，会回去fn函数查找i，而此时i已经是10了，10个函数都回到fn函数的去找i,搜索到的是同一个i,都是10. 那么，有什么办法来解决这个问题呢？ 解决的方法：（比较多） 1.我们可以通过创建另一个匿名函数强制将每次的i的值保存在一个单独的闭包中。 12345678910111213141516function fn()&#123; var arr = new Array; var i; for(i=0;i&lt;10;i++)&#123; arr[i] = function(num)&#123; return function()&#123; return num; &#125;; &#125;(i); &#125; return arr;&#125; var array = fn(); for(var j=0; j&lt;10;j++)&#123; console.log(array[j]());//0,1,2,3,4,5,6,7,8,9&#125; ( 这里返回的数组仍为函数数组，但是每个函数都又返回了一个函数，这个返回的函数return的num是在arr函数中找的，又因为每个arr函数都保存了当时的i，也就是i通过传参保存进去。所以他们能有不同的闭包环境，每个闭包都保存了各自的i。) 2.创建一个匿名函数并返回该匿名函数的立即执行 12345678910111213function fn()&#123; var arr = new Array; var i; for(i=0;i&lt;10;i++)&#123; arr[i] = (function(num)&#123; return num; &#125;)(i); &#125; return arr;&#125; var array = fn(); for(var j=0; j&lt;10;j++)&#123; console.log(array[j]);//0,1,2,3,4,5,6,7,8,9&#125; 3.使用ES6新特性let 1234567891011121314function fn()&#123; var arr = new Array; for(let i=0;i&lt;10;i++)&#123; arr[i] = function()&#123; return i; &#125; &#125; return arr;&#125; var array = fn(); for(var j=0; j&lt;10;j++)&#123; console.log(array[j]()); //0,1,2,3,4,5,6,7,8,9 &#125; 同样，可以参考高程中的相似例子（settimeout和循环与闭包的使用，改写使得输出10个10） 接下来，还有一个例子： 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, 1000);&#125; //打印出5个6 因为for循环不会创建块级作用域，5次执行的回调函数都被封闭在一个共享的全局作用域中了，因此实际上只有一个i。循环结构让我们误以为背后还有更复杂的机制在起作用，但其实没有。 解决方案代码： 12345678for (var i=1; i&lt;=5; i++) &#123; (function() &#123; var j = i; setTimeout(function timer() &#123; console.log(j); &#125;, 1000); &#125;)();&#125; 也相当于： 1234567for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j*1000); &#125;)(i);&#125; IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 （IIFE即Immediately Invoked Function Expression，立即执行函数表达式。） 还可以更简单： 12345for (var i=1; i&lt;=5; i++) &#123; setTimeout(function timer(i) &#123; console.log(i); &#125;, 10, i);&#125; 闭包的应用 模块模式 闭包的强大威力：应用于模块模式 12345678910111213141516171819202122function CoolModule() &#123; var something = 'cool'; //私有变量 var another = [1, 2, 3];//私有变量 var doSomething() &#123; console.log(something); //私有方法 &#125; function doAnother() &#123; console.log(another.join('!')); //私有方法 &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125; //以对象字面量的形式返回一个公共API对象&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 ! 每次调用都会创建一个新的模块实例。 函数柯里化 函数的柯里化，是指将本来接收多个参数的函数，变换为接收更少参数的函数，其中减少的参数，被设为了固定值。柯里化函数的使用，可以在函数被多次调用时，用来减少相同参数的重复输入, 相当于是对原函数进行了分步传值，当且仅当函数所需的所有参数都传入了对应值时，函数才会返回最终的处理结果，否则只会返回新的函数。 123456789101112131415function Curry(fn) &#123; var stored_args = Array.prototype.slice.call(arguments, 1) // 将伪数组参数转换为数组，并截取第二个之后的参数 return function () &#123; var new_args = Array.prototype.slice.call(arguments) args = stored_args.concat(new_args) return fn.apply(null, args) // 将参数赋给fn &#125;&#125;var doSomething = function (_do, something) &#123; console.log(_do+ ',' + something)&#125;var newDoSomething = Curry(doSomething, 'hello')newDoSomething('Jack') // hello,JacknewDoSomething('Tom') // hello,Tom 创建单例模式 单例模式的定义是产生一个类的唯一实例 123456789101112var getSinleInstance = (function () &#123; function Foo() &#123; this.name = 'Jack' &#125; var instance = new Foo(); return function () &#123; return instance; &#125; &#125;())var instance1 = getSinleInstance();var instance2 = getSinleInstance();console.log(instance1 === instance2) // true 原函数形成一个闭包，保存着instance这个被new 出来的实例，因此每一次都是返回相同的instance实例 另一个例子： 123456789101112var singleton = function( fn )&#123; var result; return function()&#123; return result || ( result = fn .apply( this, arguments ) ); &#125;&#125; var createMask = singleton( function()&#123; return document.body.appendChild( document.createElement('div') ); &#125;) 这里也是一个单例模式，这个例子中节点创建一次后就不再创建，因此可以大大节约Dom的开销。（这种方式其实叫桥接模式.）然而它始终还是需要一个变量result来寄存div的引用.遗憾的是js的函数式特性还不足以完全的消除声明和语句. （最后，欢迎大家围观指正）]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解this]]></title>
    <url>%2F2019%2F04%2F16%2Fthis%2F</url>
    <content type="text"><![CDATA[个人认为要行先理解了闭包，理解了js函数执行机制，作用域链之后再来理解this的指向更容易。判断es5的this指向应该按这三步： 创建时 scope 执行时 （作用域链，上下文 ） 是否被显式，隐式改变 this 是一个指针，一般指向其所在函数的执行环境（作用域链）的第二个环境对象（或者说是指向[[scope]]的第一个环境对象）（作用域链：执行环境（作用域链）= 函数内部环境 + 定义环境[[scope]]）（和函数作用域链不同的是，函数是按作用域链层层查找的（从里到外哪里有就返回哪里的），而this指向是唯一的。） 所以，this并不指向自身，也不一定指向包含它的外部函数。 可以先看一下例子： 123456789101112function baz() &#123;console.log("baz"+this);bar(); // &lt;-- bar 的调用位置&#125;function bar() &#123;console.log("bar"+this);foo(); // &lt;-- foo 的调用位置&#125;function foo() &#123;console.log("foo"+this);&#125;baz(); // &lt;-- baz 的调用位置 运行结果： 123baz[object Window]bar[object Window]foo[object Window] 我们知道，函数是词法作用域，而不是动态作用域，所以不管在哪里调用，只要this没有发生隐式或显式更改，就按其声明时的scope。 再看这段代码： 123456789101112131415161718function foo(num) &#123; console.log( "foo: " + num ); // 记录 foo 被调用的次数 this.count++;&#125;foo.count = 0;var i;for (i=0; i&lt;10; i++) &#123; if (i &gt; 5) &#123; foo( i ); &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9// foo 被调用了多少次？console.log( foo.count ); // 0 why? 执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相 同。这里的this指向window. 进入正文: this绑定规则 默认绑定：函数声明的位置 123456var a = 2;!function()&#123; // 'use strict' Cannot read property 'a' of undefined console.log(this.a); //2 默认绑定时，this指向全局对象。 console.log(this === window); //true&#125;() 默认绑定时，this指向全局对象。 注意：严格模式下(‘use strict’)this会默认绑定为undefined 隐式绑定：调用位置是否有上下文对象，或是否被某个对象拥有 123456789function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:1, b:2, foo:foo&#125;obj.foo(); 等同于foo.apply(obj)，foo被调用时，函数引用有上下文对象，隐式绑定规则会把函数调用中的this绑定到这个对象上。 但是有时候会出现隐式丢失： 12345678910function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:1, b:2, foo:foo&#125;var goo = obj.foo; // 这里相当于指针, 被当做普通函数赋值了goo(); // undefined 又比如 12345678910111213function foo() &#123;console.log( this.a );&#125;function doFoo(fn) &#123;// fn 其实引用的是 foofn(); // &lt;-- 调用位置！&#125;var obj = &#123;a: 2,foo: foo&#125;;var a = "oops, global"; // a 是全局对象的属性doFoo( obj.foo ); // "oops, global" // obj.foo 被隐式赋值给参数了 参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。 再比如： 1234567891011var obj = &#123; x:10, fn:function()&#123; function f()&#123; console.log(this);//window console.log(this.x);//undefined &#125; f(); &#125;&#125;;obj.fn(); 这里不是像上面那两个例子一样独立出去也不是传参，而是执行obj里面的立即执行函数，虽然fn是被绑定到obj上下文中的，但是f不是，。this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是JavaScript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。 还有一种常见的丢失 123456789function foo() &#123;console.log( this.a );var obj = &#123;a: 2,foo: foo&#125;;var a = "oops, global"; // a 是全局对象的属性setTimeout( obj.foo, 100 ); // "oops, global" 超时调用的代码都是在全局作用域中执行的，因此函数中this的值在非严格模式下指向window对象，在严格模式下是undefined 显式绑定 （1）利用call 和 apply, bind方法 1234567function foo() &#123;console.log( this.a );&#125;var obj = &#123;a:2&#125;;foo.call( obj ); // 2 引申知识：call 和 apply, bind的区别以及如何手写实现。 例子： 123456789101112131415function foo(sth) &#123; console.log(this.a + sth); return this.a + sth; &#125; function connect(fn,obj) &#123; return function () &#123; return fn.apply(obj,arguments); //这里传入的arguments形成了闭包 &#125; &#125; var obj = &#123; a:2 &#125; var bar = connect(foo,obj); let b = bar(3); console.log(b); //5 new绑定 首先看 new一个对象的过程发生了什么： 创建（或者说构造）一个全新的对象。 1instance = new Object(); 进行原型链的链接 1instance.__proto__ = SubType.prototype; 新对象绑定到函数调用的this,再让 SubType中的this指向instance，执行SubType的函数体内的语句（上面语句的内容就是定义两个属性并给其赋值）。 若没有return，默认返回该新对象 这就是new 操作符的工作 123456function person(a,b) &#123; this.a = a; this.b = b; &#125; var p = new person(1,2); console.log(p); 因此，在这个过程中，就会有this指向的改变 四种绑定的优先级 new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 验证： 隐式绑定和显式绑定： 123456789101112131415function foo() &#123;console.log( this.a );&#125;var obj1 = &#123;a: 2,foo: foo&#125;;var obj2 = &#123;a: 3,foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call( obj2 ); // 3obj2.foo.call( obj1 ); // 2 显然，显式绑定的优先级比隐式绑定优先级更高 new绑定和隐式绑定 12345678910111213141516function foo(something) &#123;this.a = something;&#125;var obj1 = &#123;foo: foo&#125;;var obj2 = &#123;&#125;;obj1.foo( 2 );console.log( obj1.a ); // 2obj1.foo.call( obj2, 3 );console.log( obj2.a ); // 3var bar = new obj1.foo( 4 );console.log( obj1.a ); // 2console.log( bar.a ); // 4 （这个例子需要用心观察 ） new绑定和显实绑定: 12345678910function foo(something) &#123;this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind( obj1 );bar( 2 ); //或者foo.call(obj1,2);console.log( obj1.a ); // 2var baz = new bar(3);console.log( obj1.a ); // 2console.log( baz.a ); // 3 bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a 修改为 3。相反，new 修改了硬绑定（到 obj1的）调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且baz.a 的值是 3。 因此： 对于this的判断 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 var bar = new foo() 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 var bar = foo() ES6箭头函数的this 箭头函数的 this 的指向是不能被更改的。箭头函数完全修复了this的指向，即es6之前，this总是指向词法作用域，也就是外层调用者obj，如果使用箭头函数，以前的hack写法 var that = this就不再需要了。 例如： 123456789var obj = &#123; birth: 1990, getAge: function (year) &#123; var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; return fn.call(&#123;birth:2000&#125;, year); // this.birth仍是1990 &#125;&#125;;obj.getAge(2015); // 25 123456789101112131415function foo() &#123;// 返回一个箭头函数return (a) =&gt; &#123;//this 继承自 foo()console.log( this.a );&#125;;&#125;var obj1 = &#123;a:2&#125;;var obj2 = &#123;a:3&#125;;var bar = foo.call( obj1 );bar.call( obj2 ); // 2, 不是 3 ！ foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不 行！） 还有一个之前es5被认为设计错误的例子在es6 箭头函数这里也得到了修正： 12345678910111213var x = 1var obj = &#123; x: 'obj', a: function a()&#123; var x = 'a' var b = ()=&gt;&#123; // 注意这里 var x = 'b' return this.x &#125; return b() &#125;&#125;obj.a() // 'obj' 箭头函数的 this 是没有办法被更改的。 因为无论显示更改还是隐式更改，都只能更改函数自身的 this，而箭头函数的 this 不是自己的，而是像普通变量一样从外部引进来的。 最后，欢迎大家围观指正]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内部机制]]></title>
    <url>%2F2019%2F03%2F04%2Fbrowser%2F</url>
    <content type="text"><![CDATA[浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。 浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。 浏览器的组成 用户界面 ： 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎： 在用户界面和呈现引擎之间传送指令。 呈现引擎： 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络： 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端： 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器： 用于解析和执行 JavaScript 代码。 数据存储： 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 本篇重点讲述 呈现引擎 的一些规则 呈现流程（呈现引擎） 1234561. 处理 HTML 标记，构建 DOM 树。(字节数据-字符串-Token-Node-Dom)2. 处理 CSS 标记，构建 CSSOM 树。（与上诉构建DOM树并行）(字节数据-字符串-Token-Node-CSSOM)3. 将 DOM 树和 CSSOM 树融合成渲染树 render tree。4. 根据渲染树来布局layout（回流reflow），计算每个节点的几何信息。5. 在屏幕上绘制painting（重绘）各个节点。6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 ⚠️ css文件不会阻塞html的解析，但是会阻塞html的渲染, 而js会阻塞解析。 虽然浏览器内部十分复杂，对于呈现来说， HTML 和 CSS 解析器相对于一般的语法解析还是不一样的。 HTML 解析器 HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。 简单看一下HTML的解析算法： 比如： 12345&lt;html&gt; &lt;body&gt; Hello world &lt;/body&gt;&lt;/html&gt; 初始状态是数据状态。遇到字符 &lt; 时，状态更改为“标记打开状态”。接收一个 a-z 字符会创建“起始标记”，状态更改为“标记名称状态”。这个状态会一直保持到接收 &gt; 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 html 标记。 遇到 &gt; 标记时，会发送当前的标记，状态改回“数据状态”。 标记也会进行同样的处理。目前 html 和 body 标记均已发出。现在我们回到“数据状态”。接收到 Hello world 中的 H 字符时，将创建并发送字符标记，直到接收 中的 &lt;。我们将为 Hello world 中的每个字符都发送一个字符标记。 现在我们回到“标记打开状态”。接收下一个输入字符 / 时，会创建 end tag token 并改为“标记名称状态”。我们会再次保持这个状态，直到接收 &gt;。然后将发送新的标记，并回到“数据状态”。 输入也会进行同样的处理。 CSS树的构建 和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。 呈现树的构建 WebKits RenderObject 类是所有呈现器的基类 12345678class RenderObject &#123; virtual void layout(); virtual void paint(PaintInfo); virtual void rect repaintRect(); Node* node; //the DOM node RenderStyle* style; // the computed style RenderLayer* containgLayer; //the containing z-index layer&#125; 下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。 123456789101112131415161718192021222324252627RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)&#123; Document* doc = node-&gt;document(); RenderArena* arena = doc-&gt;renderArena(); ... RenderObject* o = 0; switch (style-&gt;display()) &#123; case NONE: break; case INLINE: o = new (arena) RenderInline(node); break; case BLOCK: o = new (arena) RenderBlock(node); break; case INLINE_BLOCK: o = new (arena) RenderBlock(node); break; case LIST_ITEM: o = new (arena) RenderListItem(node); break; ... &#125; return o;&#125; 所以这就解释了为什么当 display: none;时， 元素是不占物理空间的。 reflow AND repaint reflow（回流） 浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做reflow 什么时候会导致reflow发生呢？ 123456789- 改变窗口大小- 改变文字大小- 添加/删除样式表- 内容的改变，(用户在输入框中写入内容也会)- 激活伪类，如:hover- 操作class属性- 脚本操作DOM- 计算offsetWidth和offsetHeight- 设置style属性 123🌝🌝插播一个问题 ：如何插入几万个 DOM，如何实现页面不卡顿？1. requestAnimationFrame 的方式去循环的插入 DOM2. 虚拟滚动（virtualized scroller）只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。 reflow优化建议 123456789- 不要一条一条地修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className- 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来- 尽可能不要修改影响范围比较大的 DOM- 为动画的元素使用绝对定位 absolute / fixed- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局- 避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性- 如果CSS里面有计算表达式，每次都会重新计算一遍，出发一次reflow- CSS 选择符从**右往左**匹配查找，避免节点层级过多- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。 repaint 屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。是在一个元素的外观被改变，但没有改变布局的情况下发生的当repaint发生时，浏览器会验证DOM树上所有其他节点的visibility 属性。 常见的重绘元素： color border-style visibility background text-decoration background-image background-position background-repeat outline-color border-radius box-shadow … CSS高消耗属性 12345- box-shadows- border-radius- transparency- transforms- CSS filters（性能杀手） CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下： 123451. 背景颜色2. 背景图片3. 边框4. 子代5. 轮廓 事件执行机制相关 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 最后： 还是抛出一个常见的问题： Q: 当浏览器输入URL后发生了什么？ A:]]></content>
      <tags>
        <tag>Broswser</tag>
        <tag>Engine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[站在2019看前端]]></title>
    <url>%2F2019%2F03%2F03%2Fhistory%2F</url>
    <content type="text"><![CDATA[虽然接触前端不到两年的时间，但是在这不到两年的时间，感受到前端发生了很大的变化，印象中，在 2017 年 大前端这个词才刚刚“衍生孵化”，而经过短短不到两年的发展，大前端真正迎来它的繁盛时刻，Node将触角伸向后端，npm带来各种可用的完备而成熟的库， 小程序,PWA, React Native又将触角伸向移动端，甚至像 Electron又把触角伸向pc桌面应用。前端逐渐变成“大前端”，也就是变成了全栈。实际上，由于前端相比于其他技术岗位，确实比较新，发展的速度十分快，触角也越伸越广。 可以先回顾一下前端前期的发展史： 1. 拓荒 1990 - 1994 1990年 Tim Berers-Lee 在NeXT上发明了第一个浏览器 1993年 CGI 出现，人们可以在后端动态生成页面 1994年 网景公司推出第一款商业浏览器navigator。 微软推出IE。 同年，PHP诞生，PHP将动态内容嵌入HTML中， 其性能比一般的CGI高。深刻的影响了后来的ASP,JSP。 乃至后来的JavaScript前端模板引擎。同年，W3C小组成立。 1995年 JavaScript诞生，传说JavaScript是在很短的时间内设计出来的，因此存在很多瑕疵。因此一直被嫌弃。 JavaScript 主要的语言特征： 1）借鉴C语言的基本语法 2）借鉴Java 语言的数据类型和内存管理； 3）借鉴Scheme 语言，将函数提升到“第一公民”的地位。 4）借鉴Self语言， 使用基于原型的继承机制 但是当时的JS还非常“空洞”，没有包管理机制，没有辅助SDK,内置方法屈指可数。因此，后面的主要任务就是完善和提高性能。 2. 浏览器之争 1995年 - 2005年 主要有以下这三个浏览器地位争夺 IE vs 网景 IE vs 火狐浏览器 IE vs 谷歌浏览器 第一次我们知道是 微软胜了，并且微软由于没有按照当时已有的ECMA-262 的规范来实现，也就使得前端兼容问题的诞生。 3. Prototype时期 2005年 - 2009年 prototype 是一个Sam Stephenson 写的一个非常优雅的javascript 基础类库，他是Ruby的大牛，因此prototype 的许多方法名都是来自Ruby界。 同时Prototype还解决了动画特效和Ajax请求。 4. jQuery时期 2009年 - 2012年 jQuery打破了前端开发者的编程思维，之前是按后端的开发思路来的，做一个业务就封装一个类，有了这一个类，再想办法传入dom。而jQuery是以dom为中心，开发者可以选一个或多个dom, 变成jQuery对象。进行链式调用。其次，开发者已经开始注意前后端分离。 5. 后jQuery时期 2012年 - 2016年 这一时期以RequireJs诞生为起点，以RN的出现结束。 虽然jQuery的出现让前端开发更加轻松，但是出现了以下几个问题： 1） 一个页面通常会引入十多个乃至几十个script标签。阻塞页面渲染。导致白屏。 2） 全局污染，于是衍生了各种模式规范；AMD,CMD。 同时段，NodeJS, Angular, 各种构建工具都出现了。前端开发者也开始出现了分化，有些人转向了后端，有些人开始专门搞工程化。 6. 三大框架割据时代及移动时代 2016年 - 至今 这期间： React, Angular, Vue 从PC到移动端 RN, inoc, weex， 而像前后端同构，TypeScript 也出现了，前端被越玩越“溜”，越来越自动化，越来越“高大上”。同时，可以发现，像小程序， Flutter等的出现，也预示着移动时代的到来，而PC的作用被渐渐局限在 一些To B应用以及可视化系统中。同时，今年 serveless这种开发模式衍生，前端的开发模式也在发生着一些变革，而开发模式的变革又意味着代码的重写，重构。 所以，到现在，前端的方向到底在哪里？ 首先是我意识到的几个问题： 触角越伸越广，很容易让前端开发者出现泛而不精的情况，这也是事物发展太快而使得人心浮躁的现象。再者，我认为可能会出现分久比合合就必分的趋势，前端开发会渐渐出现分化，最后还是回到原本的后端，移动端，前端分工的局面，而且其实大公司会更希望招专才。 前端原本的职责在于 呈现，交互。当然，现在各种各样的框架，“高科技”，实际上已经让前端的开发和性能比几年前都提高了很多，而且工程化生产也比之前，例如jquery时代成熟很多。并且有时候会发现，前端再怎么去优化，都没有服务端的优化来得有效。所以，现在的前端开发面临的问题在于，价值在哪里？普通的前端开发者害怕自己的技术变得局限，所以不断地将自己的价值拓展到其他端。是否脱离了原本的职责定位？ 普通需求重复而没有提升点。这其实也是很多开发者面临的问题，上手一个框架其实很容易，而深入其底层可能也是时间问题，但是需求往往是多而重复的，很有可能会出现需求越写越多，BUG越写越多，于是一直在写BUG， 当然技术的迭代也很快，很容易陷入一个问题在于：一直在学习一直在担心被淘汰，一直在写需求，BUG也越写越多，也一直在重复造轮子,“搬砖”。（当然，好处在于可以从中获得一些框架设计思想，解决问题的能力，以及对一门语言的精通程度，毕竟我发现很多面试题很容易看了又忘，而且理解不够深入，但是假如有遇到过实践过的话，就能记得很牢固。而这也是目前我认为的区分一个初级还是高级的开发者的点。当然这和从事时间无关，而和是否会总结，归纳，刻意训练有关。） 而今年在一些文章看对前端的展望，我发现稍稍有些不一样。 例如这篇文章中的解读： 10 余年前端老兵亲述：前端的未来在哪里？| 技术头条 前端为应用而生，人机交互技术是我们的生存之本，以应用为桥连接用户和数字世界是我们的使命。但长期以来前端的生存空间被压缩在 Web 领域，Digital Twin 这种新形态无疑将为我们打开一片新天地。Gartner 这份报告中还有两项技术和前端紧密相关： Immersive Technologies（沉浸式技术）：Augmented Reality(AR)、Virtual Reality(VR)、Mixed Reality(MR) 等, Smart Spaces：智慧城市、智能汽车、智能商店等。看到未来有三项战略性技术居然和前端有关，着实让人兴奋不已。不过莫急，既然是战略，也就意味着三五年内未必能开花结果。 在当下可实践的新技术中，前端相关的有：AI、Serverless/FaaS、Blockchain、IoT、AR/VR/MR、智能硬件、可视化应用开发。 这些新技术的关键路径和核心技术多数都不在前端，但我们能以使用者的身份参与进去，结合业务特点进行实践，让现有研发工作做得更好，让应用的交互体验更好。 在知乎，也出现了诸如这样的文章： 了解前端 +机器学习， 精读《30行js代码创建神经网络》，前端与人工智能。 可以看到，实际上，前端仍在不断地开拓领域，例如AI，寻找自身的价值所在，这是好事，同时难度也在不断地增加，需要学习的内容也在不断增加。 所以，这时候个人在这样的大平台下， 选择也变得越来越多，但是如何选择适合自己的一条道路，能否让自己得到更好的成长，在这个行业发挥个人的价值，就要回归到个人本身了。]]></content>
      <tags>
        <tag>发展</tag>
        <tag>历史</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开博第一篇]]></title>
    <url>%2F2019%2F03%2F01%2FfistPage%2F</url>
    <content type="text"><![CDATA[📖 第一篇，纪念一下。 谈谈自己看了那么多篇技术博文的感想。 对于一篇技术笔记，首先一定要条理清晰， 然后一定要“货比三家”，对一个知识点结合尽可能多的比较有权威性的文章或者书籍去对比着来看。取其精华，弃其糟粕。 当然，最后一定要有自己的思考，深入去问为什么，质疑其中的某些论点，尽可能自己动手实践。因为对于有些比较抽象的东西，单纯从概念来看有点晦涩，但是一旦有实践过，可以有恍然大悟的效果 😎。 而对于一篇技术文章，可能就没那么简单了，首先要尽可能新颖，这个新颖可以是角度，也可以是技术， 论点， 实践上的尝新。所以就需要在平常的开发实践中发现问题，解决问题， 或者更多的钻研技术。而且，一定会有实验论证了的过程或者已经在实际应用。这样才能有说服力。而这样的技术文章有时候就是一篇专利。 以上是我看了很多技术文章和自己写了技术文章之后的感想。最大的感触，其实是我们都应该拥有质疑精神，对于一篇写得好，点赞量收藏数很多的文章，是否真的说的都对？即使说得对，又是为什么？另外对于发博人，保证文章的质量， 不做简单的搬运工， 不为了发表而发表也是一种“技术上的素养”。 🙃]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
